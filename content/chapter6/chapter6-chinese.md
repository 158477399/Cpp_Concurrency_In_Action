#第六章 基于锁的并发数据结构设计

**本章主要内容**

>并发数据结构设计的意义<br>
>指导如何设计<br>
>实现为并发设计的数据结构<br>

在上一章中，我们对底层原子操作和内存模型有了详尽的了解。在本章中，我们将先将底层的东西放在一边(将会在第7章再次提及)，来对数据结构做一些讨论。

数据结构的选择，对于程序来说，是其解决方案的重要组成部分，当然，并行程序也不例外。当数据结构可以被多个线程所访问，其要不就是绝对不变的(其值不可能发生变化，并且不需要同步)，要不程序就要对数据结构进行正确的设计，以确保其能在多线程环境下能够(正确的)同步。一种选择是使用独立的互斥量，其可以锁住需要保护的数据(这种方法已经在第3和第4章中提到)，另一种选择是设计一种能够并发访问的数据结构。

在设计并发数据结构时，你可以使用基本多线程应用中的构建块(之前章节中有提及)，比如，互斥量和条件变量。当然，你也已经在之前的章节的例子中看到，怎样联合不同的构建块，对数据结构进行写入，并且这些构建块都是在并发环境下，线程安全的。

在本章，我们将了解一些并发数据结构设计的基本准则。然后，我们将再次重温锁和条件变量的基本构建块。最后，将去了解更为复杂的数据结构。在第7章，我们将了解到，如何正确的“返璞归真”，并且使用第5章提到的原子操作，去构建无锁的数据结构。

好吧！多说无益，让我们来看一下并发数据结构的设计，都需要些*什么*。

#6.1 为并发设计的意义何在？ 

为并发设计数据结构，意味着多个线程可以并发的对这个数据结构进行访问，线程可对这个数据结构做相同的操作，也可以做不同的操作，并且每一个线程能在自治域中看到该数据结构。并在多线程环境下，无数据丢失和损毁，所有的变量都会维持原样，且无条件竞争。这样的数据结构，称之为“线程安全”的数据结构。通常，只对数据结构中的特定类型，进行并发访问，是安全的。线程安全意味着，当有多个线程对数据结构，进行同一种并发操作，而另一种操作则需要单线程独立访问数据结构。或许是，当线程执行不同操作时，对同一数据结构的并发访问是安全的，而多线程执行同样的操作，将会出现问题。

实际的设计意义要大于上面所提到的那样：其意味为线程提供并发访问数据结构的机会。本质上，互斥量提供互斥：在互斥量的保护下，同一时间只有一个线程可以获取互斥锁。互斥量为了保护数据结构，显式的阻止了线程对数据结构的并发访问。

这就是*序列化*(*serialzation*)：线程轮流访问被互斥量保护的数据；这时，线程其实是对数据进行串行的访问，而非并发。因此，你需要对数据结构的设计进行仔细考量，确保其能并发访问。虽然一些数据结构有着比其他数据结构多的并发访问范围，但是在所有情况下的思路都是一样的：少保护区域，少序列化操作，多并发访问潜力。

在我们了解数据结构的设计之前，让我们快速的浏览一下，“在设计并发时所要考量什么的”指导建议。

##6.1.1 数据结构并发设计的指导与建议(指南)

如我刚刚提到的，当设计并发数据结构时，有两方面需要考量：确保访问是安全的，且是能真正并发访问的。我在第3章的时候已经对，如何保证数据结构是线程安全，做过简单的描述：

- 确保无线程能够看到，数据结构的“不变量”在被某一线程破坏时的状态。

- 小心那些会引起条件竞争的结接口，提供完成操作的函数，而非操作步骤。

- 注意数据结构的行为是否会产生异常，从而确保“不变量”不被破坏。

- 将死锁的概率降到最低。使用数据结构的时候，需要限制锁的范围，并且避免嵌套锁的存在。

在你思考设计细节前，你还需要考虑这个数据结构对于使用者来说有什么限制；当一个线程通过一个特殊的函数对数据结构进行访问，那么还有哪些函数能被其他线程安全的调用呢？

这是一个很关键的问题。因为，普通的构造函数和析构函数需要独立访问数据结构，所以用户在使用的时候，就必须确保这两个函数不能再构造完成前，或在析构执行时，再次调用。当数据结构支持赋值，swap()，或拷贝构造，作为数据结构的这设计者，你需要保证这些操作在并发环境下是安全的，或他们是否需要确保访问独立，即使数据结构中有大量的函数被线程所操纵，并发访问也不会出现错误。

第二个方面需要考量的是，确保真正的并发访问。这里我没法提供更多的指导意见；不过，作为一个数据结构设计者，在设计数据结构时，可以自问以下问题：

- 在锁保护的范围中，是否允许其他部分，在锁外执行？

- 数据结构不同的区域是否能被不同的互斥量所保护？

- 所有操作都需要同级保护吗？

- 能否对数据结构进行简单的修改，就能增加并发访问的概率，且不影响操作语义？

这些问题都源于一个指导思想：如何让序列访问降到最低，并且最大程度的真正并发？能够允许线程并发读取的数据结构并不少见，而单线程对数据结构的修改，必须是独立访问。这种结构，类似于`boost::shared_mutex`。同样的，这种数据结构也很常见——支持在多线程执行不同的操作时，序列化去执行相同的操作的线程(你很快就能看到)。

最简单的线程安全数据结构，通常使用的是互斥量和锁对数据进行保护。虽然这么做还是有问题，如同在第3中提到的那样，其相对简单，且保证只有一个线程在同一时间对数据结构进行一次访问。为了让你轻松的设计线程安全的数据结构，接下来我们了解一下本章基于锁的数据结构，以及第7章将提到的无锁并发数据结构的设计。

##6.2 基于锁的并发数据结构

基于锁的并发数据结构设计，需要确保，当数据被访问时上锁，以及持有锁的时间最短。对于只有一个互斥量的数据结构来说，这挺难的。你需要保证数据不被锁之外的操作所访问到，并且还要保证不会在固有结构上产生条件竞争(如第3章所述)。当你使用多个互斥量来保护数据结构中不同的区域时，问题会暴露的更明显，当操作获取多于一个互斥锁时，就有可能产生死锁。所以，在设计时，使用多个互斥量时需要格外小心。

在本节中，你将使用6.1.1节中的指导建议，来设计一些简单的数据结构——使用互斥量和锁的方式来保护数据。在每一个例子中，你都能找到，在保证数据结构是线程安全的前提下，提高数据结构并发访问的概率(机会)。

我们先来看看在第3章中，栈的实现；这个实现就是一个非常非常简单的数据结构，并且它只使用了一个互斥量。不过，这个结构线程安全吗？它离真正的并发访问又差多少呢？

###6.2.1 线程安全栈——使用锁

我们先把第3章中线程安全的栈拿过来看看：(这里试图实现一个线程安全版的`std:stack<>`)

清单6.1 线程安全栈的类定义
```c++
#include <exception>

struct empty_stack: std::exception
{
  const char* what() const throw();
};

template<typename T>
class threadsafe_stack
{
private:
  std::stack<T> data;
  mutable std::mutex m;
public:
  threadsafe_stack(){}
  threadsafe_stack(const threadsafe_stack& other)
  {
    std::lock_guard<std::mutex> lock(other.m);
    data=other.data;
  }

  threadsafe_stack& operator=(const threadsafe_stack&) = delete;

  void push(T new_value)
  {
    std::lock_guard<std::mutex> lock(m);
    data.push(std::move(new_value));  // 1
  }
  std::shared_ptr<T> pop()
  {
    std::lock_guard<std::mutex> lock(m);
    if(data.empty()) throw empty_stack();  // 2
    std::shared_ptr<T> const res(
      std::make_shared<T>(std::move(data.top())));  // 3
    data.pop();  // 4
    return res;
  }
  void pop(T& value)
  {
    std::lock_guard<std::mutex> lock(m);
    if(data.empty()) throw empty_stack();
    value=std::move(data.top());  // 5
    data.pop();  // 6
  }
  bool empty() const
  {
    std::lock_guard<std::mutex> lock(m);
    return data.empty();
  }
};
```

让我们对照着指导意见，看看它们在这里是如何应用的。

首先，如你所见，互斥量m能保证基本的线程安全，那就是对每个成员函数今进行加锁保护。这就保证在同一时间，只有一个线程可以访问到数据，所以能都保证，数据结构的“不变量”被破坏时，不会被其他线程看到。

其次，在empty()和pop()成员函数之间会存在潜在的竞争，不过因为代码会在pop()函数上锁时，显式的查询栈是否为空，所以这里的竞争是非恶性的。pop()通过对弹出值的直接返回，可以避免`std::stack<>`中top()和pop()两成员函数之间的潜在竞争。

再次，这个类中也有一些异常源。对互斥量上锁是，可能会抛出异常，不过不仅是极其罕见的(因为这意味这问题不在锁上，就是在系统资源上)，其也是每个成员函数所做的第一个操作。因为无数据修改，所以其是安全的。因为解锁一个互斥量是不会失败的，所以这里会一直很安全，并且使用`std::lock_guard<>`也能保证互斥量上锁的状态。

对data.push()①的调用可能会抛出一个异常，不是拷贝/移动数据值时，就是内存不足的时候。不管是哪种，`std::stack<>`都能保证其实安全的，所以这里也没有问题。

在第一个重载pop()中，代码可能会抛出一个empty_stack的异常②，不过数据没有被修改，所以其是安全的。对于res的创建③，也可能会抛出一个异常，这有两方面的原因：对`std::make_shared`的调用，可能无法分配出足够的内存去创建新的对象，并且内部数据需要对新对象进行引用；或者，当拷贝或移动到新分配的内存中，拷贝或移动构造返回时，可能会抛出异常。两种情况下，c++运行库和标准库能确保，这里不会出现内存泄露，并且新创建的对象(如果有的话)都能被正确销毁。因为你还是没有对栈进行任何修改，所以这里也不会有问题。当调用data.pop()④时，其能确保不抛出异常，并且返回结果，所以这个重载pop()函数“异常-安全”。

第二个重载pop()类似，除了在拷贝赋值或移动赋值的时候会抛出异常⑤，当构造一个新对象和一个`std::shared_ptr`实例时都不会抛出异常。同样，在调用data.pop()⑥（这个成员函数保证不会抛出异常）之前，依旧没有对数据结构进行修改，所以这个函数也为“异常-安全”。

最后，empty()也不会修改任何数据，所以其也是“异常-安全”函数。

###6.2.2 线程安全队列——使用锁和条件变量

###6.2.3 线程安全队列——使用细粒度锁和条件变量

