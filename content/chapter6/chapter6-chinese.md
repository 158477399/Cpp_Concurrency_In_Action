#第六章 基于锁的并发数据结构设计

**本章主要内容**

>并发数据结构设计的意义<br>
>指导如何设计<br>
>实现为并发设计的数据结构<br>

在上一章中，我们对底层原子操作和内存模型有了详尽的了解。在本章中，我们将先将底层的东西放在一边(将会在第7章再次提及)，来对数据结构做一些讨论。

数据结构的选择，对于程序来说，是其解决方案的重要组成部分，当然，并行程序也不例外。当数据结构可以被多个线程所访问，其要不就是绝对不变的(其值不可能发生变化，并且不需要同步)，要不程序就要对数据结构进行正确的设计，以确保其能在多线程环境下能够(正确的)同步。一种选择是使用独立的互斥量，其可以锁住需要保护的数据(这种方法已经在第3和第4章中提到)，另一种选择是设计一种能够并发访问的数据结构。

在设计并发数据结构时，你可以使用基本多线程应用中的构建块(之前章节中有提及)，比如，互斥量和条件变量。当然，你也已经在之前的章节的例子中看到，怎样联合不同的构建块，对数据结构进行写入，并且这些构建块都是在并发环境下，线程安全的。

在本章，我们将了解一些并发数据结构设计的基本准则。然后，我们将再次重温锁和条件变量的基本构建块。最后，将去了解更为复杂的数据结构。在第7章，我们将了解到，如何正确的“返璞归真”，并且使用第5章提到的原子操作，去构建无锁的数据结构。

好吧！多说无益，让我们来看一下并发数据结构的设计，都需要些*什么*。

#6.1 为并发设计的意义何在？ 

为并发设计数据结构，意味着多个线程可以并发的对这个数据结构进行访问，线程可对这个数据结构做相同的操作，也可以做不同的操作，并且每一个线程能在自治域中看到该数据结构。并在多线程环境下，无数据丢失和损毁，所有的变量都会维持原样，且无条件竞争。这样的数据结构，称之为“线程安全”的数据结构。通常，只对数据结构中的特定类型，进行并发访问，是安全的。线程安全意味着，当有多个线程对数据结构，进行同一种并发操作，而另一种操作则需要单线程独立访问数据结构。或许是，当线程执行不同操作时，对同一数据结构的并发访问是安全的，而多线程执行同样的操作，将会出现问题。

实际的设计意义要大于上面所提到的那样：其意味为线程提供并发访问数据结构的机会。本质上，互斥量提供互斥：在互斥量的保护下，同一时间只有一个线程可以获取互斥锁。互斥量为了保护数据结构，显式的阻止了线程对数据结构的并发访问。

这就是*序列化*(*serialzation*)：线程轮流访问被互斥量保护的数据；这时，线程其实是对数据进行串行的访问，而非并发。因此，你需要对数据结构的设计进行仔细考量，确保其能并发访问。虽然一些数据结构有着比其他数据结构多的并发访问范围，但是在所有情况下的思路都是一样的：少保护区域，少序列化操作，多并发访问潜力。

在我们了解数据结构的设计之前，让我们快速的浏览一下，“在设计并发时所要考量什么的”指导建议。

##6.1.1 数据结构并发设计的指导与建议(指南)

如我刚刚提到的，当设计并发数据结构时，有两方面需要考量：确保访问是安全的，且是能真正并发访问的。我在第3章的时候已经对，如何保证数据结构是线程安全，做过简单的描述：

- 确保无线程能够看到，数据结构的“不变量”在被某一线程破坏时的状态。

- 小心那些会引起条件竞争的结接口，提供完成操作的函数，而非操作步骤。

- 注意数据结构的行为是否会产生异常，从而确保“不变量”不被破坏。

- 将死锁的概率降到最低。使用数据结构的时候，需要限制锁的范围，并且避免嵌套锁的存在。

在你思考设计细节前，你还需要考虑这个数据结构对于使用者来说有什么限制；当一个线程通过一个特殊的函数对数据结构进行访问，那么还有哪些函数能被其他线程安全的调用呢？

这是一个很关键的问题。因为，普通的构造函数和析构函数需要独立访问数据结构，所以用户在使用的时候，就必须确保这两个函数不能再构造完成前，或在析构执行时，再次调用。当数据结构支持赋值，swap()，或拷贝构造，作为数据结构的这设计者，你需要保证这些操作在并发环境下是安全的，或他们是否需要确保访问独立，即使数据结构中有大量的函数被线程所操纵，并发访问也不会出现错误。

第二个方面需要考量的是，确保真正的并发访问。这里我没法提供更多的指导意见；不过，作为一个数据结构设计者，在设计数据结构时，可以自问以下问题：

- 在锁保护的范围中，是否允许其他部分，在锁外执行？

- 数据结构不同的区域是否能被不同的互斥量所保护？

- 所有操作都需要同级保护吗？

- 能否对数据结构进行简单的修改，就能增加并发访问的概率，且不影响操作语义？

这些问题都源于一个指导思想：如何让序列访问降到最低，并且最大程度的真正并发？能够允许线程并发读取的数据结构并不少见，而单线程对数据结构的修改，必须是独立访问。这种结构，类似于`boost::shared_mutex`。同样的，这种数据结构也很常见——支持在多线程执行不同的操作时，序列化去执行相同的操作的线程(你很快就能看到)。

最简单的线程安全数据结构，通常使用的是互斥量和锁对数据进行保护。虽然这么做还是有问题，如同在第3中提到的那样，其相对简单，且保证只有一个线程在同一时间对数据结构进行一次访问。为了让你轻松的设计线程安全的数据结构，接下来我们了解一下本章基于锁的数据结构，以及第7章将提到的无锁并发数据结构的设计。