#第二章 线程管理

**本章主要内容**

>启用线程，让指定代码在新线程上运行
>等待线程结束与置之不理继续运行
>唯一的线程标识

好的！看来你已经决定在应用中使用并发和多线程了。现在做点什么呢？如何去启动线程？如何知道它们已经结束了？还是，如何持续监视它们？C++标准库让线程管理变得相对容易很多，你将在后面看到，只需要管理`std::thread`对象中关联的线程即可。不过，标准库的灵活性，会让这些任务不会如同想象的那么简单。
在这一章，我将从一些基本的东西开始说起：启动一个线程，等待其结束，或让它在后台运行。再看看怎么给已经启动的线程函数传递参数，以及怎么讲一个线程的所有权从一个`std::thread`对象移交给另一个。最后，我们来看看怎么确定线程数，以及识别特殊的线程。

##2.1 线程管理基础

每一个C++程序至少有一个线程：线程执行**main()**函数。你的程序可以添加额外的线程，使用其他的函数作为入口点。之后这些线程与原始线程（以main()函数作为入口点的线程）同时运行。如同程序在**mian()**函数执行完会退出一样，当线程中的入口函数执行完成，那么线程也就会退出。如你将看到的那样，如果你为一个线程创建了一个`std::thread`对象，你需要等待这个线程结束；但前提是，你得启动它。下面我们就来启动线程。

###2.1.1 启动线程

如同第一章，线程在一个`std::thread`对象创建（为线程指定任务）时启动。在最简单的情况下，任务也会很简单，通常是无参数无返回（*void-returning*）的函数。这种函数在其所属线程上运行，直到函数执行完毕，线程也就结束了。在一些极端情况下，在线程运行时，任务中的函数对象需要通过某种通讯系统进行参数的传递，或者执行一系列独立操作；线程的停止，也是通过通讯系统传递信号进行控制的。线程要做什么或从哪里启动，其实都无关紧要。不过，使用C++线程库启动线程，通常都可以归结为构造了`std::thread`对象：

```c++
void do_some_work();
std::thread my_thread(do_some_work);
```

这只是一个简单的例子。当让，你也要保证`<thread>`头文件包含其中，能让编译器识别`std::thread`类。如同大多数C++标准库一样，`std::thread`可用于任何可调用（*callable*）类型，你可以将带有函数调用符类型的实例传入`std::thread`类中，用来替换默认的构造函数。

```c++
class background_task
{
public:
  void operator()() const
  {
    do_something();
    do_something_else();
  }
};
background_task f;
std::thread my_thread(f);
```

在这个例子中，所提供的函数对象会复制到新线程的存储空间当中，函数对象的执行和调用都在那进行的。函数对象的副本与原始的函数对象行为是相同的，但是函数对象副本得到的结果，有时却与我们期望的不同。
有件事需要注意，当把函数对象传入到线程构造函数中时，需要避免叫做“[最令人头痛的语法解析](http://en.wikipedia.org/wiki/Most_vexing_parse)”(*C++’s most vexing parse*, [中文简介](http://qiezhuifeng.diandian.com/post/2012-08-27/40038339477) )。如果你传递一个临时变量，而不是一个命名的变量；之后C++编译器就会将其解析为一个函数声明，而不是一个对象的定义。

例如：
```c++
std::thread my_thread(background_task());
```

这里相当与声明了一个名为**my_thread**，带有一个参数（是一个函数指针，指向一个没有参数并返回**background_task**对象的函数），并且返回一个`std::thread`对象的函数，而非启动了一个线程。你使用在前面命名函数对象的方式，或使用多组括号①，再或使用新统一的初始化语法②，来避免这个问题。举例如下：

```c++
std::thread my_thread((background_task()));  // 1
std::thread my_thread{background_task()};    // 2
```

使用lambda表达式也能避免这个问题。lambda表达式是C++11的一个性特性，
它允许使用一个可以捕获局部变量的局部函数（可以避免传递参数，参见2.2节）。想要具体的了解lambda表达式，可以阅读附录A的A.5节。之前的例子可以改写为lambda表达式的类型，如下：

```c++
std::thread my_thread([](
  do_something();
  do_something_else();
});
```

当你启动了线程，你需要明确一下自己的决定，是要等待线程结束（*加入*式——参见2.1.2节），还是让其自主运行（*分离*式——参见2.1.3节）。如果你
在`std::thread`对象销毁之前没有做出决定，那么你的程序就会终止（` std::thread`的析构函数会调用`std::terminate()`）。因此，即便是有异常的存在，你也需要确保线程能够正确的加入（*joined*）或分离（*detached*）。在2.1.3节中，会有对应的方法来处理这种情况。需要注意的是，你必须在`std::thread`对象销毁之前做出决定——可能在你加入或分离线程之前，线程就已经结束了，之后如果再去分离它，线程可能会再`std::thread`对象销毁之后继续运行下去。
如果不等待线程结束，你必须保证线程结束之前，可访问数据的有效性。这不是一个新问题——在单线程代码中，在对象销毁之后再去访问，也是未定义的行为——但是，线程的生命周期却增加了这个问题发生的几率。
这种情况很可能会在这种情况下碰到：当线程还没结束，函数已经退出时，线程函数还持有函数局部变量的指针或引用的时候。下面的清单中就展示了这样的一种情况。

清单2.1  函数已经结束，但线程依旧访问局部变量
```c++
struct func
{
  int& i;
  func(int& i_) : i(i_) {}
  void operator() ()
  {
    for (unsigned j=0 ; j<1000000 ; ++j)
    {
      do_something(i);           // 1. 潜在访问隐患：悬空引用
    }
  }
};

void oops()
{
  int some_local_state=0;
  func my_func(some_local_state);
  std::thread my_thread(my_func);
  my_thread.detach();          // 2. 不等待线程结束
}                                            // 3. 新线程可能还在运行
```

在这个例子中，因为你已经明确的决定不等待线程结束了（使用了detach() ②），所以当**oops()**函数执行完成时 ③，与新线程中的函数可能还在运行中。如果线程还在运行中，它就会去调用**do_something(i)**函数 ①，这时就会去访问已经销毁了的变量。这挺像一个单线程程序——允许在函数完成后继续持有局部变量的指针或引用，这从来就不是一个好主意——因为这种情况发生的时，并不是很明显，所以这样的代码会使得多线程程序更容易出现错误。
处理这种情况常规方法是使线程函数自身的功能齐全，数据复制到线程中，而不是复制到共享数据中。如果你使用一个可调用的对象作为线程函数，这个对象就会赋值到线程中去，然后原始对象就能立即销毁了。但是，你还需要谨慎的对待对象中包含的指针和或引用，例如清单2.1所示。使用一个能访问局部变量的函数去创建一个线程是一个糟糕的主意，除非能够确定线程会在函数完成前结束。
此外，你可以通过加入的方式来确保线程在函数完成前结束。








