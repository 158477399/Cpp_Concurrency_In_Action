#第二章 线程管理

**本章主要内容**

>启用线程，让指定代码在新线程上运行<br>
>等待线程结束与置之不理继续运行<br>
>唯一的线程标识<br>

好的！看来你已经决定在应用中使用并发和多线程了。现在做点什么呢？如何去启动线程？如何知道它们已经结束了？还是，如何持续监视它们？C++标准库让线程管理变得相对容易很多，你将在后面看到，只需要管理`std::thread`对象中关联的线程即可。不过，标准库的灵活性，会让这些任务不会如同想象的那么简单。
在这一章，我将从一些基本的东西开始说起：启动一个线程，等待其结束，或让它在后台运行。再看看怎么给已经启动的线程函数传递参数，以及怎么讲一个线程的所有权从一个`std::thread`对象移交给另一个。最后，我们来看看怎么确定线程数，以及识别特殊的线程。

##2.1 线程管理基础

每一个C++程序至少有一个线程：线程执行**main()**函数。你的程序可以添加额外的线程，使用其他的函数作为入口点。之后这些线程与原始线程（以main()函数作为入口点的线程）同时运行。如同程序在**mian()**函数执行完会退出一样，当线程中的入口函数执行完成，那么线程也就会退出。如你将看到的那样，如果你为一个线程创建了一个`std::thread`对象，你需要等待这个线程结束；但前提是，你得启动它。下面我们就来启动线程。

###2.1.1 启动线程

如同第一章，线程在一个`std::thread`对象创建（为线程指定任务）时启动。在最简单的情况下，任务也会很简单，通常是无参数无返回（*void-returning*）的函数。这种函数在其所属线程上运行，直到函数执行完毕，线程也就结束了。在一些极端情况下，在线程运行时，任务中的函数对象需要通过某种通讯系统进行参数的传递，或者执行一系列独立操作；线程的停止，也是通过通讯系统传递信号进行控制的。线程要做什么或从哪里启动，其实都无关紧要。不过，使用C++线程库启动线程，通常都可以归结为构造了`std::thread`对象：

```c++
void do_some_work();
std::thread my_thread(do_some_work);
```

这只是一个简单的例子。当让，你也要保证`<thread>`头文件包含其中，能让编译器识别`std::thread`类。如同大多数C++标准库一样，`std::thread`可用于任何可调用（*callable*）类型，你可以将带有函数调用符类型的实例传入`std::thread`类中，用来替换默认的构造函数。

```c++
class background_task
{
public:
  void operator()() const
  {
    do_something();
    do_something_else();
  }
};
background_task f;
std::thread my_thread(f);
```

在这个例子中，所提供的函数对象会复制到新线程的存储空间当中，函数对象的执行和调用都在那进行的。函数对象的副本与原始的函数对象行为是相同的，但是函数对象副本得到的结果，有时却与我们期望的不同。
有件事需要注意，当把函数对象传入到线程构造函数中时，需要避免叫做“[最令人头痛的语法解析](http://en.wikipedia.org/wiki/Most_vexing_parse)”(*C++’s most vexing parse*, [中文简介](http://qiezhuifeng.diandian.com/post/2012-08-27/40038339477) )。如果你传递一个临时变量，而不是一个命名的变量；之后C++编译器就会将其解析为一个函数声明，而不是一个对象的定义。

例如：
```c++
std::thread my_thread(background_task());
```

这里相当与声明了一个名为**my_thread**，带有一个参数（是一个函数指针，指向一个没有参数并返回**background_task**对象的函数），并且返回一个`std::thread`对象的函数，而非启动了一个线程。你使用在前面命名函数对象的方式，或使用多组括号①，再或使用新统一的初始化语法②，来避免这个问题。举例如下：

```c++
std::thread my_thread((background_task()));  // 1
std::thread my_thread{background_task()};    // 2
```

使用lambda表达式也能避免这个问题。lambda表达式是C++11的一个性特性，
它允许使用一个可以捕获局部变量的局部函数（可以避免传递参数，参见2.2节）。想要具体的了解lambda表达式，可以阅读附录A的A.5节。之前的例子可以改写为lambda表达式的类型，如下：

```c++
std::thread my_thread([](
  do_something();
  do_something_else();
});
```

当你启动了线程，你需要明确一下自己的决定，是要等待线程结束（*加入*式——参见2.1.2节），还是让其自主运行（*分离*式——参见2.1.3节）。如果你
在`std::thread`对象销毁之前没有做出决定，那么你的程序就会终止（` std::thread`的析构函数会调用`std::terminate()`）。因此，即便是有异常的存在，你也需要确保线程能够正确的加入（*joined*）或分离（*detached*）。在2.1.3节中，会有对应的方法来处理这种情况。需要注意的是，你必须在`std::thread`对象销毁之前做出决定——可能在你加入或分离线程之前，线程就已经结束了，之后如果再去分离它，线程可能会再`std::thread`对象销毁之后继续运行下去。
如果不等待线程结束，你必须保证线程结束之前，可访问数据的有效性。这不是一个新问题——在单线程代码中，在对象销毁之后再去访问，也是未定义的行为——但是，线程的生命周期却增加了这个问题发生的几率。
这种情况很可能会在这种情况下碰到：当线程还没结束，函数已经退出时，线程函数还持有函数局部变量的指针或引用的时候。下面的清单中就展示了这样的一种情况。

清单2.1  函数已经结束，但线程依旧访问局部变量
```c++
struct func
{
  int& i;
  func(int& i_) : i(i_) {}
  void operator() ()
  {
    for (unsigned j=0 ; j<1000000 ; ++j)
    {
      do_something(i);           // 1. 潜在访问隐患：悬空引用
    }
  }
};

void oops()
{
  int some_local_state=0;
  func my_func(some_local_state);
  std::thread my_thread(my_func);
  my_thread.detach();          // 2. 不等待线程结束
}                                            // 3. 新线程可能还在运行
```

在这个例子中，因为你已经明确的决定不等待线程结束了（使用了detach() ②），所以当**oops()**函数执行完成时 ③，与新线程中的函数可能还在运行中。如果线程还在运行中，它就会去调用**do_something(i)**函数 ①，这时就会去访问已经销毁了的变量。这挺像一个单线程程序——允许在函数完成后继续持有局部变量的指针或引用，这从来就不是一个好主意——因为这种情况发生的时，并不是很明显，所以这样的代码会使得多线程程序更容易出现错误。
处理这种情况常规方法是使线程函数自身的功能齐全，数据复制到线程中，而不是复制到共享数据中。如果你使用一个可调用的对象作为线程函数，这个对象就会赋值到线程中去，然后原始对象就能立即销毁了。但是，你还需要谨慎的对待对象中包含的指针和或引用，例如清单2.1所示。使用一个能访问局部变量的函数去创建一个线程是一个糟糕的主意，除非能够确定线程会在函数完成前结束。
此外，你可以通过加入的方式来确保线程在函数完成前结束。

###2.1.2 等待线程完成

如果需要等待线程结束，你对相关的`std::tread`实例使用**join()**。在2.1清单中，将`my_thread.detach()`替换为`my_thread.join()`，就可以确保局部变量在线程完成后，才被销毁。在这种情况下，因为原始线程在其生命周期中并没有做什么事，所以使得用一个独立的线程去运行这个函数变得收益甚微，但在实际编程中，原始线程要么有自己的工作要做；要么会启动多个子线程来做一些有用的工作，并等待这些线程结束。
**join()**是简单粗暴的——等待线程完成或不等待。如有你需要对等待中的线程有更细致的控制，比如看一下某个线程是否结束，或者只等待一段时间（超过时间就判定为**超时**）。想要做到这些，你需要使用一些其他的机制，比如条件变量和期待（*futures*），相关的讨论我们会在第四章继续。调用**join()**的行为，还清理了线程相关的存储部分，这样`std::thread`对象将不再与已经完成的线程有任何关联。这就意味着，你只能对一个线程使用一次**join()**;一旦已经使用过**join()**，`std::thread`对象就不能再次加入了，当对其使用**joinable()**时，函数将返回**否**（*false*）。

###2.1.3 特殊情况下的等待

如前面所提到的，你需要对一个还未销毁的`std::thread`对象使用**join()**或**detach()**。如果你想要分离一个线程，你可以在线程启动后，直接使用**detach()**进行分离。如果你打算等待对应线程，你需要细心挑选调用**join()**的地方。如果有异常在线程运行之后，join()调用之前抛出，就意味着很这次调用会被跳过。
为了避免你的应用被抛出的异常所终止，你需要作出一个决定。通常，当你倾向于在无异常的情况下使用**join()**时，你需要在异常处理过程中调用**join()**，从而避免生命周期的问题。我在下面的程序清单中做了一个例子。

清单 2.2 等待线程完成
```c++
struct func; // 定义在清单2.1中
void f()
{
  int some_local_state=0;
  func my_func(some_local_state);
  std::thread t(my_func);
  try
  {
    do_something_in_current_thread();
  }
  catch(...)
  {
    t.join();  // 1
    throw;
  }
  t.join();  // 2
}
```

清单2.2中的代码使用了try/catch块，确保访问本地状态的线程退出后，函数才结束。当函数正常退出时，会执行到②处；当函数执行过程中抛出异常，程序会执行到①处。冗余的try/catch块能轻易的捕获轻量级错误，所以这种情况，并非是理想的。如需确保线程在函数之前结束——查看是否因为线程函数使用了局部变量的引用，或其他原因——而后再确定一下程序可能会退出的途径，无论正常与否，然后提供一个简洁的机制，来做这些事。
一种方式是使用“资源获取即是初始化方式”（RAII，Resource Acquisition Is Initialization），并且提供一个类，在析构函数中使用**join()**，如同下面清单中的代码。看它如何简化**f()**函数。

清单 2.3 使用RAII等待线程完成
```c++
class thread_guard
{
  std::thread& t;
public:
  explicit thread_guard(std::thread& t_):
    t(t_)
  {}
  ~thread_guard()
  {
    if(t.joinable()) // 1
    {
      t.join();      // 2
    }
  }
  thread_guard(thread_guard const&)=delete;   // 3
  thread_guard& operator=(thread_guard const&)=delete;
};

struct func; // 定义在清单2.1中

void f()
{
  int some_local_state=0;
  func my_func(some_local_state);
  std::thread t(my_func);
  thread_guard g(t);
  do_something_in_current_thread();
}    // 4
```

当线程执行到 ④ 处时，局部对象就要被逆序销毁了。因此，**thread_guard**对象**g**是第一个被销毁的，这时线程在析构函数中被加入②到原始线程中。即使**do_something_in_current_thread**抛出一个异常，这个销毁的动作，依旧会发生。
在**thread_guard**的析构函数的测试中，首先判断线程是否已加入①，如果没有会调用**join()**②进行加入。这很重要，因为**join()**只能对给定的对象调用一次，所以当给以加入的线程再次进行加入操作，将会导致一些错误。
拷贝构造函数和拷贝赋值操作被标记为`=delete`③，这是为了不让编译器自动生成它们。直接对一个对象进行拷贝或赋值是危险的，因为这可能会丢失已经加入了的线程。通过删除声明，任何尝试赋值一个**thread_guard**对象的操作都会引发一个编译错误。想要了解删除函数的更多知识，请参阅附录A的A.2节。
如果你不想等待线程结束，你使用分离（*detaching*）来避免异常安全（*exception-safety*）的问题。这就打破了线程与`std::thread`对象的联系，也确保了`std::terminate()`不会在`std::thread`对象销毁后被调用，即使线程仍然在后台运行着。