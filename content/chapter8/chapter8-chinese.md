#第八章 并发代码设计

**本章主要内容**

- 线程间划分数据的技术<br>
- 影响并发代码性能的因素<br>
- 性能因素是如何影响数据结构的设计<br>
- 多线程代码中的异常安全<br>
- 可扩展性<br>
- 并行算法的实现<br>

之前章节中着重于介绍使用C++11中的新工具来写并发代码。在6、7章中我们了解到，如何使用这些工具来设计可以并发访问的基本数据结构。这就好比一个木匠不仅要知道如何做一个合页，或是一个组合柜，亦或一个桌子，并发的代码的使用，要比使用或设计基本数据结构多的多。这里需要将眼界放宽，所以需要构建更大的结构，进行高效的工作。我将使用已经多线程化的C++标准库算法作为例子，不过同样的原则也适用于对应用程序的扩展。

认真的思考如何进行并发化设计，对于每个编程项目来说都是很重要的。不过，在写多线程代码的时候，需要比写序列化代码考虑的因素多。不仅包括一般性因素，例如：封装，耦合和聚合(这些在很多软件设计书籍中，有很详细的介绍)，还要考虑哪些数据需要共享，如何同步访问数据，哪些线程需要等待哪些线程，等等。

在本章，我们将来关注这些问题，从高层(但也是基本的)考虑，如何使用线程，哪些代码应该在哪些线程上执行；以及，这将如何影响代码的清晰度，从底层细节上了解，如何构建共享数据来优化性能。

那么我们就先来看一下如何在线程间划分工作。

##8.1 线程间划分工作的技术

试想某时，你被要求负责建造一座房子。为了完成任务，你需要挖地基，砌墙，添加水暖，接入电线，等等。理论上，如果你很擅长建造屋子，那么这些事情都可以由你来完成，但是这样可能就要花费很长很长时间，并且需要不断的切换任务。或者，你可以雇佣一些人来帮助你完成房子的建造。那么现在你需要决定你要雇多少人，以及需要雇佣人员具有什么样的技能。比如，你可以雇几个人，这几个人什么都会。现在你还得不断的切换任务，不过因为雇佣了很多人，就要比之前完成的速度快很多。

或者，你可以雇佣一个包工队(专家组)，由瓦工，木匠，电工和水管工组成。你的包工队只做其精通的，所以当没有水暖任务时，水管工会喝着茶或咖啡，坐在那里休息。还是因为人多的缘故，要比之前一个人的速度快很多，并且水管工在收拾厕所的时候，电工可以将电线连接到厨房，不过当没有属于自己的任务时，有人就会休息。即使是有人在休息，你可能还是能感觉到雇佣包公队的方式，要比雇佣一群什么都会的人快。你的包工队不需要更换工具，并且每人对自己的任务可能要比都会的人做的快。是快还是慢，取决于特定的情况——你需要尝试，并且进行观察。

即使你雇佣包工队，你依旧可以选择拥有不同人数的团队。可能在一个团队中，瓦工的数量超过电工。同样，这会是一种补足，并且在建造不止一座房子的时候，会改变工作的整体效率。即使水管工没有太多的任务，在建造过一次房子后，你依旧能让他总是处于忙碌的状态。当包工队无事可做的时候，你是不会给他们钱的；即使每次工作只有那么几个人工作，你还需要负担整个团队的开销。

关于建造例子已经足够说明问题了；这些与线程所做的事情有什么关系呢？好吧，这些问题也会发生在线程上。你需要决定你要使用多少个线程，并且这些线程应该去做什么。还需要决定是使用“能工巧匠”的线程去完成所有的任务，还是使用“专业”线程只去完成一件事情，或将两种方法混合。在使用并发的时候，你需要作出诸多选择来驱动并发，这里的选择会决定代码的性能和清晰度。因此，这里的选择至关重要，所以可以在你设计应用程序的结构时，再作出适当的决定。在本节中，我们将看到很多划分任务的技术，那就先从线程间划分数据开始吧！

###8.1.1 在线程处理前对数据进行划分

最简单的并行算法，就是`std::for_each`的并行化，其会对一个数据集中每个元素执行同一个操作。为了并行化该算法，你可以为数据集中每个元素分配一个处理线程。如何划分才能获得最佳的性能，着很大程度上取决于数据结构实现的细节，在之后又关性能问题的章节会再提及此问题。

最简单的非配方式：为第一组N个元素分配一个线程，下一组N个元素再分配一个线程，以此类推，如图8.1所示。不管数据怎么分，每个线程都会对分配给它的元素进行操作，不过并不会和其他线程进行沟通，直到处理完成。

![](https://raw.githubusercontent.com/xiaoweiChen/Cpp_Concurrency_In_Action/master/images/chapter8/8-1.png)

图8.1 向线程分发连续的数据块

使用过MPI(*Message Passing Interface*)[1]和OpenMP[2]的人对这个结构一定很熟悉：一项任务被分割成多个，放入一个并行任务集中，执行线程独立的执行这些任务，并且结果在会有主线程中合并。这种方式在2.4节中的accumulate的例子中使用过了；在这个例子中，所有并行任务和主线程的任务都是累积和。对于for_each来说，主线程将无事可做，因为这个计算不需要最终处理。

最后一步对于并行程序来说十分重要；如清单2.8中那样原始的实现，最后一步就是一个串行的。不过，这一步同样也是能被并行化的；accumulate实际上是一个递减操作，所以清单2.8中，当线程数量大于一个线程上最小处理项的数目，可以对accumulate进行递归调用。或者，在工作线程就能像做一个完整的任务一样，对步骤进行递减，而非将每次都产生新的线程。

虽然这个技术十分强大，但是并不是哪里都适用。有时不能像之前那样，对任务进行整齐的划分，因为只有对数据进行处理后，才能进行明确的划分。这里特别适用了递归算法，就像快速排序；下面就来看看这种特别的方式。

###8.1.2 递归划分

快速排序有两个最基本的步骤：将数据划分到中枢元素之前或之后，然后对中枢元素之前和之后的两半数组再次进行快速排序。这里不能通过对数据的简单划分达到并行，因为，只有在一次排序结束后，才能知道哪些项在中枢元素之前和之后。当要对这种算法进行并行化，很自然的会想到使用递归。每一级的递归都会多次调用quick_sort函数，因为需要知道哪些元素在中枢元素之前和自后。递归调用是完全独立的，因为其访问的是不同的数据集，并且每次迭代都能并发执行。图8.2展示了这样的递归划分。

![](https://raw.githubusercontent.com/xiaoweiChen/Cpp_Concurrency_In_Action/master/images/chapter8/8-2.png)

图8.2 递归划分数据

在第4章中，已经见过这种实现。比起对大于和小于的数据块递归调用函数，使用`std::async()`可以对每一级的小于数据块进行同步。使用`std::async()`时，C++线程库就能决定何时让一个新线程执行任务，以及让其同步的执行任务。

很重要的是：当对一个很大的数据集进行排序时，当每层递归都产生一个新线程，最后就会产生大量的线程。你会看到其对性能的影响，如果有太多的线程存在，那么你的应用将会运行的很慢。如果数据集过于庞大，会将线程用完。那么在递归的基础上进行任务的划分，就是一个不错的注意；你只需要将一定数量的数据打包后，交给线程即可。`std::async()`可以出里这种简单的情况，不过其不是唯一的选择。

另一种选择是使用`std::thread::hardware_concurrency()`函数来确定线程的数量，就像在清单2.8中的并行版accumulate()一样。然后，比起每次递归调用启用一个新线程，你可以将已排序的数据推到线程安全的栈上，就像第6、7章中提及的。当线程无所事事，不是因为已经完成对自己数据块的梳理，就是因为在等待一组一排序数据产生，线程可以从栈上获取这组数据，并且对其排序。

下面的代码就是使用以上方式进行的实现

清单8.1 使用栈的并行快速排序算法——等待数据块排序
```c++
template<typename T>
struct sorter  // 1
{
  struct chunk_to_sort
  {
    std::list<T> data;
    std::promise<std::list<T> > promise;
  };

  thread_safe_stack<chunk_to_sort> chunks;  // 2
  std::vector<std::thread> threads;  // 3
  unsigned const max_thread_count;
  std::atomic<bool> end_of_data;

  sorter():
    max_thread_count(std::thread::hardware_concurrency()-1),
    end_of_data(false)
  {}

  ~sorter()  // 4
  {
    end_of_data=true;  // 5

    for(unsigned i=0;i<threads.size();++i)
    {
      threads[i].join();  // 6
    }
  }

  void try_sort_chunk()
  {
    boost::shared_ptr<chunk_to_sort > chunk=chunks.pop();  // 7
    if(chunk)
    {
      sort_chunk(chunk);  // 8
    }
  }

  std::list<T> do_sort(std::list<T>& chunk_data)  // 9
  {
    if(chunk_data.empty())
    {
      return chunk_data;
    }

    std::list<T> result;
    result.splice(result.begin(),chunk_data,chunk_data.begin());
    T const& partition_val=*result.begin();

    typename std::list<T>::iterator divide_point=  // 10
       std::partition(chunk_data.begin(),chunk_data.end(),
        [&](T const& val){return val<partition_val;});

    chunk_to_sort new_lower_chunk;
    new_lower_chunk.data.splice(new_lower_chunk.data.end(),
       chunk_data,chunk_data.begin(),
       divide_point);

    std::future<std::list<T> > new_lower=
      new_lower_chunk.promise.get_future();
    chunks.push(std::move(new_lower_chunk));  // 11
    if(threads.size()<max_thread_count)  // 12
    {
      threads.push_back(std::thread(&sorter<T>::sort_thread,this));
    }

    std::list<T> new_higher(do_sort(chunk_data));

    result.splice(result.end(),new_higher);
    while(new_lower.wait_for(std::chrono::seconds(0)) !=
       std::future_status::ready)  // 13
    {
      try_sort_chunk();  // 14
    }

    result.splice(result.begin(),new_lower.get());
    return result;
  }

  void sort_chunk(boost::shared_ptr<chunk_to_sort> const& chunk)
  {
    chunk->promise.set_value(do_sort(chunk->data));  // 15
  }

  void sort_thread()
  {
    while(!end_of_data)  // 16
    {
      try_sort_chunk();  // 17
      std::this_thread::yield();  // 18
    }
  }
};

template<typename T>
std::list<T> parallel_quick_sort(std::list<T> input)  // 19
{
  if(input.empty())
  {
    return input;
  }
  sorter<T> s;

  return s.do_sort(input);  // 20
}
```

这里，parallel_quick_sort函数⑲代表了sorter类①的功能，其支持在栈上简单的存储无序数据块②，并且对线程进行设置③。do_sort成员函数⑨主要做的就是对数据进行划分⑩。相较于对每一个数据块产生一个新的线程，这次会将这些数据块推到栈上⑪；并在在有备用处理器⑫的时候，再产生新的线程。因为小于部分的数据块可能由其他线程进行处理，那么你就得等待这个线程完成⑬。为了让所有事情顺利进行(只有一个线程和其他所有线程都忙碌时)，当线程处于等待状态时⑭，就让本线程尝试处理栈上的数据。try_sort_chunk只是从栈上弹出一个数据块⑦，并且对其进行排序⑧，将结果存在promise中，让线程对已经存在于栈上的数据块进行提取⑮。

当end_of_data没有被设置时⑯，新生成的线程还在尝试从栈上获取需要排序的数据块⑰。在循环检查中，也要给其他线程机会⑱可以从栈上取下数据块进行更多的操作。这里的实现依赖sorter类④对线程的清理。当所有数据都已经排序完成，do_sort将会返回(即使还有工作线程在运行)，所以主线程将会从parallel_quick_sort⑳中返回，在这之后会销毁sorter对象。析构函数会设置end_of_data标志⑤，以及等待所有线程完成工作⑥。这里对标志的设置将终止线程函数内部的循环⑯。

这个方案中，就不用为spawn_task产生的无数线程所困扰，并且也不用再依赖C++线程库来为你选择执行线程的数量(就像`std::async()`那样)。该方案制约线程数量的值就是`std::thread::hardware_concurrency()`的值，这样就能避免任务过于频繁的切换了。不过这里还有一个问题：线程管理，以及线程间的通讯。要解决这两个问题就要增加代码的复杂程度。虽然线程对数据项是分开处理的，不过所有对栈的访问都能添加新的数据块到栈中，还有删除数据块以作处理。这里重度的竞争会降低性能，即使使用无锁(无阻塞)栈，原因将会在后面提到。

这个方案使用到了一个特别版的线程池——所有线程的任务都来源于一个等待链表，然后线程会去完成任务，完成任务后会再来链表提取任务。这个线程池很有问题(包括对工作链表的竞争)，这个问题的解决方案将在第9章提到。关于多处理器的问题，将会在本章后面的章节中有更为详细的讨论(详见8.2.1)。

几种划分方法：1，处理前划分；2，递归划分(都需要事先知道数据的长度固定)，还有上面的那种划分方式。事情并非总是这样好解决；当数据是动态生成，或是通过外部输入，那么这里的办法就不适用了。在这种情况下，基于任务类型对工作进行划分的方式，就要好于基于数据的划分方式。

###8.1.3 通过任务类型划分工作

通过为每个线程分配不同的数据块，对在线程间工作进行划分(无论是之前就划分好，还是使用递归划分的方式)仍然停留在假设阶段，因为这里没有个线程对每个数据块的操作是相同的。另一种选择是让线程做专门的工作，也就是每个线程做不同的工作，就像水管工和电工在建造一所屋子的时候所做的不同工作那样。线程可能会对同一段数据进行操作，不过在它们对数据进行处理的目的都不相同。

对分工的排序，也就是从并发分离关注结果；每个线程都有不同的任务，这就意味着真正意义上的线程独立。其他线程偶尔会向特定线程交付数据，或是通过触发事件的方式来进行处理，不过总体而言，每个线程只需要关注自己所要做的事情即可。其本身就是基本良好的设计；每一段代码只对自己的部分负责。

**分离关注**

当有多个任务需要持续运行一段时间，或需要及时处理进入事件(比如，按键事件或传入网络数据)，且还有其他任务正在运行时，单线程应用处理冲突采用的是单职责原则。在单线程的世界中，手写完成的代码会执行任务A(部分)后，再去执行任务B(部分)，再检查按钮事件，再检查传入的网络包，然后在循环回去，执行任务A。这将会使得任务A复杂化，因为需要存储其完成状态，以及定期从主循环中返回。如果在循环中添加了很多任务，那么程序将运行的很慢；并且用户会发现，在他/她按下按键后，很久之后才会有反应。我确定你已经在一些程序中见过这种情况：你给程序分配一项任务后，发现接口会封锁，直到这项任务完成。

这里就是线程进入的地方。当你使用独立线程执行任务时，操作系统会帮你处理接口的问题。在任务A的代码中，你可以专注于执行任务，而不用为保存状态和从主循环中返回，以及这样做需要花多长时间而担心。操作系统会自动保存状态，当需要的时候，将线程切换到任务B或任务C。如果目标系统是多核的或多个处理器的，任务A和任务B可很可能真正的并发执行。处理按键时间或网络包的代码，现在就能及时执行了，所有事情都完成的很好：用户得到了及时的相应；当然，作为开发者只需要写具体操作的代码即可，不用再将控制分支和使用用户交互混在一起了。

听起来不错，玫瑰色的愿景呀。不过，事实真的像上面所说的那样么？一切取决于细节。如果每件事都是独立的，那么线程间就不需要交互，这样的话一切都很简单了。不幸的是，现实没那么美好。后台那些优雅的任务，进场会被用户要求做一些事情，并且它们需要通过更新用户接口的方式，来让用户知道它们完成了这些任务。或者，用户可能想要取消任务，这就需要用户接口发送一条消息，告知后台任务停止运行。这两种情况需要认真考虑，设计，以及适当的同步，不过担心的部分还是分离的。用户接口线程还是只能处理用户接口，当其他线程告诉它要做什么时，用户接口线程会进行更新。同样，后台线程只运行它们所关注的任务；只是有时会发生“允许任务被其他线程所停止”的情况。在这两种情况下，后台线程需要照顾来自其他线程的请求，其只知道它们请求与自己的任务有所关联。

在多线程下有两个危险需要分离关注。第一个是对错误担忧的分离。主要表现为线程间共享着很多的数据，或者不同的线程要相互等待；这两种情况都归结于线程间需要太密切的交互。当这种情况发生，那就需要看一下为什么需要这么多交互。当所有交互都有关于同样的问题，这时应该使用单线程来解决，并将对同一原因引用的线程提取出来。或者，当两个需要频繁的交流，且没有其他线程时，那么就可以将这两个线程合为一个线程。

当通过任务类型对线程间的任务进行划分，你不应该让你自己处于完全隔离的状态。当多个输入数据集需要使用同样的操作序列，可以将序列中的操作分成多个阶段，来让每个线程执行。

**划分任务序列**

当任务会应用到相同操作序列去处理独立的数据项，就可以使用流水线(*pipeline*)使用系统提供的并发。这好比一个物理管道：数据流从管道一端进入，在进行一系列操作后，从管道另一端出去。

使用这种方式划分工作，可以为流水线中的每一阶段操作创建一个独立线程。当一个操作完成，数据元素会放在队列中，以供下一阶段的线程提取使用。这就允许第一个线程在完成对于第一个数据块的操作，并要对第二个数据块进行操作时，第二个线程可以对第一个数据块执行管线中的第二个操作。

这就是在线程间划分数据的一种替代方案(就像8.1.1描述的那样)；这种方式适合于在操作开始前，还对输入数据处长度不清楚的情况。例如，数据来源可能是从网络，或者队列中第一个操作可能是通过扫描文件系统来确定要处理的文件。

流水线对于队列中耗时的操作处理的也很合理；通过对线程间任务的划分，就能对应用的性能所有改善。假设你有20个数据项，需要在四核的机器上处理，并且每一个数据项需要四个步骤来完成操作，每一步都需要3秒来完成。如果你将数据分给了四个线程，那么每个线程上就有5个数据项要处理。假设在处理的时候，没有其他线程对处理过程进行影响，在12秒后4个数据项处理完成，24秒后8个数据项处理完成，以此类推。当20个数据项都完成操作，就需要1分钟的时间。在管线中就会完全不同。四步可以交给四个内核。那么现在，第一个数据项可以被每一个核进行处理，所以其还是会消耗12秒。的确，在12秒后你就能得到一个处理过的数据项，这相较于数据划分并没有好多少。不过，当流水线流动起来，事情就会不一样了；在第一个核处理第一个数据项后，数据项就会交给下一个内核，所以第一个核在处理完第一个数据项后，其还可以对第二个数据项进行处理。那么在12秒后，每3秒将会得到一个已处理的数据项，这就要好于每隔12秒完成4个数据项。

为什么整批处理的时间要长于流水线呢？因为你需要在最终核开始处理第一个元素前等待9秒。更平滑的操作，能在某些情况下获益。考虑如下情况：当一个系统是用来播放高清数字视频的。为了让视频能够播放，你至少要保证25帧每秒的解码速度。同样的，这些图像需要有均匀的间隔，才会给观众留有连续播放的感觉；一个应用可以在1秒解码100帧，不过在解完就需要暂停1s的时，那这个应用就是没有用的。另一方面，观众能接受在视频开始播放的时候有一定的延迟。这种情况，并行使用流水线就能得到稳定的解码率。

看了这么多线程间划分工作的技术，接下来让我们来看一下在多线程系统中有哪些因素会影响性能，并且这些因素是如何影响你选择划分方案的。

##8.2 影响并发代码性能的因素

当你在多处理系统中，使用并发的方式来提高代码的效率时，你需要了解一下有哪些因素会影响并发的效率。即使已经使用多线程对关注进行分离，你还需要确定是否会对性能造成负面影响。因为，在崭新16核机器上应用的速度与单核机器相当时，用户是不会放过你的。

之后你会看到，在多线程代码中有很多因素会影响性能——对线程处理的数据做一些简单的改动(其他不变)，都可能看到对性能产生戏剧性的效果。所以，多言无益，让我们来看一下这些因素吧，从明显的开始：目标系统有多少个处理器？

###8.2.1 有多少个处理器？

有多少个处理收是影响多线程应用的首要因素。在很多情况下，你对目标硬件会很熟悉，并且针对硬件进行设计，并在目标系统或副本上进行测量。如果是这样，那你很幸运；通常情况下，要知道这些都是很奢侈的。你可能在一个类似的平台上进行开大，不过你所使用的平台与目标平台的差异是很重要的。例如，你可能会在一个双芯或四芯的系统上做开发，不过你的用户四通可能就只有一个处理器(可能有很多芯)，或多个单芯处理器，亦或是多核多芯的处理器。在不同的平台上，并发程序的行为和性能特点就可能完全不同，所以你需要仔细考虑那些地方会被影响到，如果可能，对其进行测试。

一个单核16芯的处理器和四核双芯或十六核单芯的处理器相同：在任何系统上，都能运行16个并发线程。当线程数量少于16个时，会有处理器处于空闲状态(除非系统同时需要运行其他应用，不过我们暂时忽略这种可能性)。另一方面，当多于16个线程在运行的时候(都没有阻塞或等待)，应用将会浪费处理器的运算时间在线程间进行切换，就让第1章所述。这种情况发生时，我们称其为*超额认购*(*oversubscription*)。

为了让应用线程数量扩展，和硬件所支持的并发线程数量一致，C++标准线程库提供了`std::thread::hardware_concurrency()`。使用这个函数就能了解可以在给定硬件上扩展的线程数量了。

需要谨慎使用`std::thread::hardware_concurrency()`；因为你的代码不会考虑有其他线程在系统上运行，除非已经将系统信息进行共享。最坏的情况就是，到多线程同时调用使用`std::thread::hardware_concurrency()`的函数来对线程数量进行扩展，这样将导致庞大的超额认购。`std::async()`就能避免这个问题，因为标准库会对所有的调用进行适当的安排。同样，谨慎的使用线程池也可以避免这个问题。

不过，即使你已经考虑到所有要在应用中运行的线程，你的程序还要受在同时运行的其他程序影响。虽然，在单用户系统中，使用多个CPU密集型应用程序很罕见，但在某些领域，这种情况就是很常见的了。虽然有系统能提供选择线程数量的机制(为应用)，不过这种机制已经超出C++标准的范围。这里的一种选择是使用与`std::async()`类似的工具，来为同步所有执行任务所需的线程数量做考虑。另一种选择就是限制每个应用使用的处理芯个数。我倒是希望，这种限制能反映到`std::thread::hardware_concurrency()`上面(不能保证)。如果你需要处理这种情况，可以看一下你所使用的系统说明，了解一下是否有相关选项可供使用。

这种情况的一种变化时，理想算法可能会取决于问题规模与处理单元的比值。大规模并行系统中有很多的处理单元，算法可能就会同时执行很多操作，让应用更快的结束；这就要快于，执行较少操作的平台，因为该平台上的每一个处理器只能执行很少的操作。

随着处理器数量的增加，另一个问题就会来影响性能：多个处理器尝试访问同一个数据。

###8.2.2 数据争用与乒乓缓存

当两个线程并发的在不同处理器上执行，并且对同一数据进行读取，这样通常不会出现问题；因为数据将会拷贝到每个线程的缓存中，并且可以让两个处理器同时进行处理。不过，当有线程对数据进行修改的时候，这个修改需要更新到其他核芯的缓存中去，这就要耗费一定的时间。根据线程的操作性质，以及使用到的内存序，这样的修改可能会让第二个处理器停下来，等待硬件内存更新缓存中的数据。即使精确的时间取决于硬件的物理结构，不过根据CPU指令，这是一个特别特别慢的操作，相当于执行成百上千个独立指令。

思考下面简短的代码段：

```c++
std::atomic<unsigned long> counter(0);
void processing_loop()
{
  while(counter.fetch_add(1,std::memory_order_relaxed)<100000000)
  {
    do_something();
  }
}
```

counter变量是全局的，所以任何线程都能调用processing_loop()去修改同一个变量。因此，当有新增加的处理器时，必须要counter变量在其缓存内做一份拷贝，再自己通过改变其值，或其他线程发布的方式对缓存中的拷贝副本进行更新。即使用`std::memory_order_relaxed`，编译器还是不会为任何数据去做同步操作，fetch_add是一个“读-改-写”操作，因此就要对最新的值进行检索。如果另一个线程在另一个处理器上执行同样的代码，counter的数据需要在两个处理器之间进行传递，那么这两个处理器的缓存中间存有counter的最新值(当counter的值增加时)。如果do_something()足够短，或有很多处理器来对这段代码进行处理，那么处理器将会发现他们之间会互相等待；一个处理器准备更新这个值，不过另一个处理器正在修改这个值，所以该处理器就不得不等待第二个处理器更新完成，并且完成更新传递时，才能执行更新。这种情况被称为“高竞争”(*high contention*)。如果处理器很少需要互相等待，那么这种情况就是“低竞争”(*low contention*)。

像在这个循环中，counter的数据将在每个缓存中传递若干次。这就叫做“乒乓缓存”(*cache ping-pong*)，这种清苦会对应用的性能有重大的影响。当一个处理器因为等待缓存转移而停止运行，这时这个处理器就不能做任何事情，可能等待线程所要完成的操作很有用，所以对于整个应用来说，这就是一个坏消息。

你可能会想，这种情况不会发生在你身上；因为，你没有使用任何循环。你确定吗？那么互斥锁呢？如果你需要在循环中放置一个互斥量，那么你的代码就和之前从数据访问的角度差不多了。为了锁住互斥量，另一个线程必须将数据进行转移，就能弥补处理器的互斥性，并且对数据进行修改。当这个过程完成时，将会再次对互斥量进行修改，并对线程进行解锁，之后护士数据将会传递到下一个需要互斥量的线程上去。转移时间，就是第二个线程等待第一个线程释放互斥量的时间：

```c++
std::mutex m;
my_data data;
void processing_loop_with_mutex()
{
  while(true)
  {
    std::lock_guard<std::mutex> lk(m);
    if(done_processing(data)) break;
  }
}
```

接下来看看最糟糕的部分：当数据和互斥量已经准备好让多个线程进访问，之后当系统中的核心数和处理器数量增加时，很可能看到高竞争，以及一个处理器不得不等待其他处理器。如果在多线程情况下，能更快的对同样级别的数据进行处理时，线程就会对数据以，及互斥量进行竞争。这里有很多这样的情况，很多线程会同时尝试对互斥量进行获取，或者同时访问源自变量，等等。

对互斥量的竞争通常不同于对原子操作的竞争，最简单的原因是，互斥量通常使用操作系统级别的序列化线程，而非处理器级别的。如果有足够的线程去执行任务，当有线程正在等待互斥量时，操作系统会安排其他线程来执行任务，而处理器只会在其他线程运行在目标处理器上时，让该处理器停止工作。不过，对互斥量的竞争，将会影响这些线程的性能；毕竟，只能让一个线程在同一时间运行。

回顾第3章，一个很少更行的数据结构可以被一个“单作者，多读者”互斥量(详见3.3.2)。乒乓缓存效应可以抵消互斥所带来的收益(工作量不利时)，因为所有线程访问数据(即使是读者线程)都会对互斥量进行修改。随着处理器对数据的访问的次数增加，对于互斥量的竞争就会增加，并且持有互斥量的缓存行将会在核芯中进行转移，因此会潜在的增加对不良的锁获取和释放次数。有一些方法可以改善这个问题，其本质上就是让互斥量对多行缓存进行保护，不过这样的互斥量需要自己去实现。

如果乒乓缓存是一个糟糕的现象，那么该怎么避免它呢？就会在本章后面看到，答案会与提高并发潜能的指导意见相结合：减少两个线程对同一个内存位置的竞争。

虽然，要实现起来并不见。即使一个给定内存位置被一个线程所访问，可能还是会有乒乓缓存的存在,是因为另一种叫做“伪共享”(*false sharing*)的效应。

###8.2.3 伪共享

处理器缓存通常不会用来处理在单个存储位置；不过，其会用来处理称为“缓存行”(*cache lines*)的内存块。这些内存块通常大小为32或64字节，不过实际大小需要由正在使用着的处理器模型来决定。因为硬件缓存进处理缓存行大小的内存块，较小的数据项就在同一内存行的相邻内存位置上。有时，这样的设定还是挺不错的：当线程访问的一组数据是在同一数据行中，这对于应用的性能来说就要好于向多个缓存行进行传播。不过，当在同一缓存行的是无关数据，且需要被不同线程访问，这就会造成性能问题。

假设你有一个int类型的数组，并且有一组线程可以访问数组的元素，不过对数组的访问很是频繁(包括更新)。通常int类型的大小要小于一个缓存行，在同一个缓存行中可以存储多个数据项。因此，即使每个线程都能对数据中的成员进行访问，硬件缓存还是会产生乒乓缓存。每当线程访问0号数据项，并对其值进行更新时，缓存行的所有权就需要转移给执行该线程的处理器，这仅是为了让更新1号数据项的线程获取1号线程的所有权。缓存行是共享的，及时没有数据存在，因此这里使用“伪共享”(*false sharing*)来称呼这种方式。这里的解决办法就是对数据进行构造，让同一线程访问的数据项存在临近的内存中(就像是放在同一缓存行中)，这样那些能被独立线程访问的数据将分布在相距很远的地方，并且可能是存储在不同的缓存行中。你将在本章接下来的内容中看到，这种思路对代码和数据设计的影响。

如果多线程访问同一内存行是一种糟糕的情况，那么在单线程情况下内存布局将会如何带来哪些影响呢？

###8.2.4 如何让数据紧凑？

然而，伪共享发生的原因是：某个线程所要访问的数据过于接近另一线程的数据，另一个是与数据布局相关的陷阱会直接影响单线程的性能。问题在于数据过于接近：当数据能被单线程访问时，那么数据就已经在内存中展开，这就像是分布在不同的缓存行上。另一方面，当内存中有紧凑的数据能被单线程访问，这就像是数据分布在同一缓存行上。因此，当数据已传播，那么将会有更多的缓存行将会从处理器的缓存上加载数据，这会增加访问内存的延迟，以及降低数据的系能(与紧凑的数据存储地址相比较)。

同样的，如果数据已传播，那么在给定缓存行上就即包含于当前线程有关和无关的数据。在极端情况下，当有更多的数据存在于缓存中，你会对数据投以更多的关注，而非这些数据去做了什么。这就会浪费宝贵的缓存空间，增加处理器缓存缺失的情况，即使这个数据项曾经在缓存中存在过，还需要从主存中添加对应数据项到缓存中，因为在缓存中其位置已经被其他数据所占有。

现在，对于单线程代码来说就很关键了，我们何至于此呢？原因就是*任务切换*(*task switching*)。如果系统中的线程数量要比核芯多，每个核上都要运行多个线程。这就会增加缓存的压力，为了避免伪共享，你努力让不同线程访问不同缓存行。因此，当处理器切换线程的时候，就要对不同内存行上的数据进行重新加载(当不同线程使用的数据跨越了多个缓存行时)，而非对缓存中的数据保持原样(当线程中的数据都在同一缓存行时)。

如果线程数量要多于内核或处理器数量，操作系统可能也会选择将一个线程安排给这个核芯一段时间，之后再安排给另一个核芯一段时间。因此就需要将缓存行从一个内核上，转移到另一个内核上；这样的话，就需要转移很多缓存行，也就意味着要耗费很多时间。虽然操作系统通常避免这样的情况发生，不过当其发生的时候，对性能就会有很大的影响。

当有超级多的线程准备运行时(非等待状态)，任务切换问题就会频繁发生。这个问题我们之前也接触过：超额认购(*oversubscription*)。

###8.2.5 超额认购和频繁的任务切换

在多线程系统中，通常线程的数量要多于处理的数量。不过，线程经常会花费时间来等待外部I/O完成，或被互斥量阻塞，亦或等待条件变量，等等；所以等待不是问题。应用使用额外的线程来完成有用的工作，而非让线程在处理器处以闲置状态时继续等待。

这也并非长久之计。如果你有很多额外线程，那这时就会有很多线程准备执行，而且数量远远大于可用处理器的数量，而操作系统就会忙于在任务间切换，以确保每个任务都有时间运行。如我们在第1章所见，这将增加切换任务的时间开销，和缓存问题造成同一结果。当无限制的产生新线程，超额认购就会加剧，就像第4章的递归快速排序那样；或者在通过任务类型对任务进行划分的时候，线程数量大于处理器数量，这里对性能影响的主要来源是CPU的能力，而非I/O。

如果你只是简单的通过数据划分生成多个线程，那你可以限定工作线程的数量，就像8.1.2节中那样。如果超额认购是由于对工作的天然划分而产生，那么使用一种不同的划分方式对这种问题就没有太多益处了。之前的情况是，需要选择一个合适的划分方案，可能需要对目标平台有着更加详细的了解，不过这也只限于性能已经无法接受，或是某种划分方式已经无法提高性能的时候。

其他因素也会影响多线程代码的性能。即使CPU类型和时钟周期相同，乒乓缓存的开销可以让程序在两个单核处理器和在一个双核处理器上，产生巨大的性能差，不过这只是那些对性能影响可见的因素。那么接下来，让我们看一下这些因素如何影响代码与数据结构的设计。

##8.3 为多线程性能设计数据结构

在8.1节中，我们看到了各式各样的划分方法；并且在8.2节，我们了解了对性能影响的各种因素。如何在设计数据结构的时候，使用这些信息提高多线程代码的性能呢？这里的问题与第6、7章中的问题不同，之前是关于如何设计能够安全、并发访问的数据结构。在8.2节中，单线程中使用的数据布局就会对性能产生巨大冲击(即使数据并未与其他线程进行共享)。

关键的是，当为多线程性能而设计数据结构的时候，需要考虑*竞争*(*contention*)，*伪共享*(*false sharing*)，以及*数据距离*(*data proximity*)。这三个因素对于性能都有着重大的影响，并且你通常可以改善的是改变数据布局，或者将赋予其他线程的数据元素进行修改。首先，让我们来看一个轻松方案：在线程间划分数组元素。

###8.3.1 为复杂操作划分数组元素

假设你有一些重数学计算任务，比如，你需要将两个很大的矩阵进行相乘。对于矩阵相乘来说，就是将第一个矩阵中的首行每个元素和第二个矩阵中首列每个元素相乘后，再相加，从而产生新矩阵中左上角的第一个元素。然后，第二行和第一列，产生新矩阵第一列上的第二个结果，第二行和第二列，产生新矩阵中第二列的第一个结果，以此类推。如图8.3所示，高亮展示的就是在新矩阵中第二行-第三列中的元素产生的过程。

![](https://raw.githubusercontent.com/xiaoweiChen/Cpp_Concurrency_In_Action/master/images/chapter8/8-3.png)

图8.3 矩阵相乘

现在，让我们假设两个举证都有上千行和上千列，为了使用多线程来优化矩阵乘法。通常，非稀疏矩阵可以用一个大数组来代表，也就是第二行的元素紧随着第一行的，以此类推。为了完成矩阵乘法，这里就需要三个大数组。为了优化性能，你需要仔细考虑数据访问的模式，特别是向第三个数组中写入的方式。

线程间划分工作是有很多种方式的。假设矩阵的行或列数量大于处理器的数量，可以让每个线程计算出结果矩阵列上的元素，或是行上的元素，亦或是计算一个子矩阵。

回顾一下8.2.3和8.2.4节，对于一个数组来说，访问连续的元素是最好的方式，而非对随意位置进行访问，因为这将会减少缓存的使用，并且减少伪共享的概率。如果要让每个线程处理几行，线程需要读取第一个矩阵中的每一个元素，并且读取第二个矩阵上的相关行上的数据，不过这里只需要对列的值进行写入。给定的两个矩阵释义行连续的方式存储，这就意味着当你访问第一个矩阵的第一行的前N个元素，然后是第二行的前N个元素，以此类推(N是列的数量)。其他线程会访问每行的的其他元素；很明显的，你应该访问相邻的列，所以从行上读取的N个元素也是连续的，这将最大程度的减少伪共享的几率。当然，如果空间已经被N个元素所占有，且N个元素也就是每个缓存行上具体的存储元素数量，这就会让伪共享的情况消失，因为线程将会对独立缓存行上的数据进行操作。

另一方面，当每个线程处理一组行，那么就需要读取第二个矩阵上的每一个数据，还要读取第一个矩阵中的相关行上的值，不过这里只需要对行上的值进行写入。因为矩阵是以行连续的方式存储，那么现在可以以N行的方式访问所有的元素。如果再次选择相邻行，这就意味着线程现在只能写入N行；这里有不能被其他线程所访问的连续内存块。那么让线程对每组列进行处理就是一个改进，因为伪共享只可能有在一个内存块的最后几个元素和下一个元素的开始几个上发生，不过具体的时间还要使用目标架构来决定。

第三个选择——将矩阵分成小矩阵块？这可以看作为先对列进行划分，在对行进行划分。因此，在划分列的时候，同样有伪共享的问题存在。如果你可以选择内存块所拥有行的数量，那么就可以有效的避免伪共享；将大矩阵划分为小块，在读取方面来说是有好处的：就不在需要读取整个源矩阵了。这里，你只需要读取目标矩形里面相关行列的值就可以了。具体的来看，考虑1,000行和1,000列的两个矩阵相乘。就会有1百万个元素。如果有100个处理器，这样就可以每次处理10行的数据，也就是10,000个元素。不过，为了计算着10,000个元素，就需要对第二个矩阵中的全部内容进行访问(1百万个元素)，再加上10,000个相关行(第一个矩阵)上的元素，大概就要访问1,010,000个元素。另外，硬件能处理100x100的数据块(总共10,000个元素)，这就需要对第一个矩阵中的100行进行访问(100x1,000=100,000个元素)，还有第二个矩阵中的100列(另外100,000个)。这才只有200,000个元素，也就是需要五轮读取才能完成。如果这里读取的元素少一些，缓存缺失的情况就会少一些，对于性能来说就更好一些。

因此，将矩阵分成小块或正方形的块，要比使用单线程来处理少量的列好的多。当然，可以根据源矩阵的大小和处理器的数量，在运行时对块的大小进行调整。和之前一样，当性能是很重要的指标，那么需要对目标架构上的各项指标进行测量。

如果不做矩阵乘法，那么该如何对上面提到的方案进行应用呢？同样的原理可以引用与任何情况，这种情况就是有很大的数据块需要在线程间进行划分；仔细观察所有数据访问的各个方面，以及确定性能问题产生的原因。在各种领域中，出现问题的情况都很相似：改变划分方式就恩能够提高性能，而不用需要对基本算法进行任何修改。

OK，我们已经了解了如何访问数组会对性能产生影响。那么其他类型的数据结构呢？

###8.3.2 其他数据结构中的数据访问模式

根本上讲，同样的考虑适用于当想要优化数据结构的数据访问模式，就像优化对数组的访问那样：

- 尝试调整数据在线程间的分布，这样就能让同一线程中的数据紧密联系在一起。

- 尝试减少给定线程上所需的数据量。

- 尝试让不同线程访问不同的存储位置，以避免伪共享。

当然，应用于其他数据结构上会比较麻烦。例如，对二叉树划分就要比其他数困难，有用与没用要取决于树的平衡性，以及需要划分的节点数量。同样，树的的属性决定了其节点会动态的进行分配，并且在不同的地方进行释放。

现在，节点在不同的地方释放倒不是一个严重的问题，不过这就意味着处理器需要在缓存中存储很多东西。这实际上是有好处的。当多线程需要旋转数的时候，就需要对树中的所有节点进行访问，不过当树中的节点只包括指向实际值的指针时，当需要的时候，处理器只能从主存中对数据进行加载。如果数据正在被访问线程所修改，这就能避免节点数据，以及树数据结构间的伪共享。

这里就和用一个互斥量来保护数据类似了。假设你有一个简单的类，包含一些数据项和一个用于保护数据的互斥量(在多线程环境下)。如果互斥量和数据项在内存中很接近，这对与一个需要获取互斥量的线程来说是很理想的情况；需要的数据可能早已存入处理器的缓存中了，因为在之前为了对互斥量进行修改，已经加载了需要的数据。不过，这还有一个缺点：当其他线程尝试锁住互斥量时(第一个线程还没有是释放)，线程就能对对应的数据项进行访问。互斥锁是当做一个“读-改-写”原子操作实现的，对于相同位置的操作都需要先获取互斥量，如果互斥量已锁，那就会调用系统内核。这种“读-改-写”操作，可能会让数据存储在缓存中，让线程获取的互斥量变得毫无作用。从目前互斥量的发展来看，这并不是个问题;这个线程不会直到互斥量解锁，才会接触到互斥量。不过，当互斥量共享一缓存行，其中存储的是线程已使用的数据，这时拥有互斥量的线程将会遭受到性能打击，因为踢打线程尝试锁住互斥量。

一种测试伪共享问题的方法是：对大量的数据块填充数据，让不同线程并发的进行访问。比如，你可以使用：

```c++
struct protected_data
{
  std::mutex m;
  char padding[65536];  // 65536字节已经超过一个缓存行的数量级
  my_data data_to_protect;
};
```

用来测试互斥量竞争或

```c++
struct my_data
{
  data_item1 d1;
  data_item2 d2;
  char padding[65536];
};
my_data some_array[256];
```

用来测试数组数据中的伪共享。如果这样能够提高性能，你就能知道伪共享在这里的确存在。

当然，在设计并发的时候有更多的数据访问模式需要考虑，那么现在让我们一起来看一些附加的注意事项。

##8.4 设计并发代码的注意事项

目前为止，在本章中我们已经看到了很多在线程间划分工作的方法，影响性能的因素，以及这些因素数如何影响你选择数据访问访问模式和数据结构的。虽然，已经有了很多设计并发代码的内容。你还需要考虑很多事情，比如异常安全和可扩展性。随着系统中核数的增加，性能越来越高(无论是在减少执行时间，还是增加吞吐率)，那么这样的代码称为“可扩展代码”。理想状态下，性能随着核数的增加而线性增长，也就是当系统有100个处理器时，其性能是系统只有1和核时的100倍。

虽然，即使非扩展性代码依旧可以正常工作——单线程应用就无法扩展——例如，异常安全是一个正确性问题。如果你的代码不是异常安全的，最终会破坏不变量，或是造成条件竞争，亦或是你的应用以外终止，因为某个操作会抛出异常。有了这个想法，那么我们就率先来看一下异常安全的问题。

###8.4.1 并行算法中的异常安全

异常安全是衡量C++代码一个很重要的指标，并发代码也不例外。实际上，相较于串行算法，并行算法常会要求你格外要求你注意异常问题。当一个操作在串行算法中抛出一个异常，算法只需要考虑对其本身进行处理，以避免资源泄露和损坏不变量；这里可以允许异常传递给调用者，由调用者对异常进行处理。通过对比，在并行算法中很多操作要运行在独立的线程上。在这种情况下，异常就不再允许被传播，因为这将会使调用堆栈出现问题。如果一个函数在创建一个新线程后带着异常推出，那么这个应用将会终止。

作为一个具体的例子，让我们回顾一下清单2.8中的parallel_accumulate函数：

清单8.2 `std::accumulate`的原始并行版本(源于清单2.8)
```c++
template<typename Iterator,typename T>
struct accumulate_block
{
  void operator()(Iterator first,Iterator last,T& result)
  {
    result=std::accumulate(first,last,result);  // 1
  }
};

template<typename Iterator,typename T>
T parallel_accumulate(Iterator first,Iterator last,T init)
{
  unsigned long const length=std::distance(first,last);  // 2

  if(!length)
    return init;

  unsigned long const min_per_thread=25;
  unsigned long const max_threads=
    (length+min_per_thread-1)/min_per_thread;

  unsigned long const hardware_threads=
    std::thread::hardware_concurrency();
  
  unsigned long const num_threads=
    std::min(hardware_threads!=0?hardware_threads:2,max_threads);
  
  unsigned long const block_size=length/num_threads;
  
  std::vector<T> results(num_threads);  // 3
  std::vector<std::thread> threads(num_threads-1);  // 4

  Iterator block_start=first;  // 5
  for(unsigned long i=0;i<(num_threads-1);++i)
  {
    Iterator block_end=block_start;  // 6
    std::advance(block_end,block_size);
    threads[i]=std::thread(  // 7
      accumulate_block<Iterator,T>(),
      block_start,block_end,std::ref(results[i]));
    block_start=block_end;  // 8
  }
  accumulate_block()(block_start,last,results[num_threads-1]);  // 9

  std::for_each(threads.begin(),threads.end(),
    std::mem_fn(&std::thread::join));

  return std::accumulate(results.begin(),results.end(),init);  // 10
}
```

###8.4.2 可扩展性和Amdahl定律

###8.4.3 使用多线程隐藏延迟

###8.4.4 使用并发提高响应能力

##8.5 在实践中设计并发代码

###8.5.1 并行实现：`std::for_each`

###8.5.2 并行实现：`std::find`

###8.5.3 并行实现：`std::partial_sum`

##8.6 小结


----------

【1】 http://www.mpi-forum.org/

【2】 http://www.openmp.org/