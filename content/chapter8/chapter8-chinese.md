#第八章 并发代码设计

**本章主要内容**

- 线程间划分数据的技术<br>
- 影响并发代码性能的因素<br>
- 性能因素是如何影响数据结构的设计<br>
- 多线程代码中的异常安全<br>
- 可扩展性<br>
- 并行算法的实现<br>

之前章节中着重于介绍使用C++11中的新工具来写并发代码。在6、7章中我们了解到，如何使用这些工具来设计可以并发访问的基本数据结构。这就好比一个木匠不仅要知道如何做一个合页，或是一个组合柜，亦或一个桌子，并发的代码的使用，要比使用或设计基本数据结构多的多。这里需要将眼界放宽，所以需要构建更大的结构，进行高效的工作。我将使用已经多线程化的C++标准库算法作为例子，不过同样的原则也适用于对应用程序的扩展。

认真的思考如何进行并发化设计，对于每个编程项目来说都是很重要的。不过，在写多线程代码的时候，需要比写序列化代码考虑的因素多。不仅包括一般性因素，例如：封装，耦合和聚合(这些在很多软件设计书籍中，有很详细的介绍)，还要考虑哪些数据需要共享，如何同步访问数据，哪些线程需要等待哪些线程，等等。

在本章，我们将来关注这些问题，从高层(但也是基本的)考虑，如何使用线程，哪些代码应该在哪些线程上执行；以及，这将如何影响代码的清晰度，从底层细节上了解，如何构建共享数据来优化性能。

那么我们就先来看一下如何在线程间划分工作。

##8.1 线程间划分工作的技术

试想某时，你被要求负责建造一座房子。为了完成任务，你需要挖地基，砌墙，添加水暖，接入电线，等等。理论上，如果你很擅长建造屋子，那么这些事情都可以由你来完成，但是这样可能就要花费很长很长时间，并且需要不断的切换任务。或者，你可以雇佣一些人来帮助你完成房子的建造。那么现在你需要决定你要雇多少人，以及需要雇佣人员具有什么样的技能。比如，你可以雇几个人，这几个人什么都会。现在你还得不断的切换任务，不过因为雇佣了很多人，就要比之前完成的速度快很多。

或者，你可以雇佣一个包工队(专家组)，由瓦工，木匠，电工和水管工组成。你的包工队只做其精通的，所以当没有水暖任务时，水管工会喝着茶或咖啡，坐在那里休息。还是因为人多的缘故，要比之前一个人的速度快很多，并且水管工在收拾厕所的时候，电工可以将电线连接到厨房，不过当没有属于自己的任务时，有人就会休息。即使是有人在休息，你可能还是能感觉到雇佣包公队的方式，要比雇佣一群什么都会的人快。你的包工队不需要更换工具，并且每人对自己的任务可能要比都会的人做的快。是快还是慢，取决于特定的情况——你需要尝试，并且进行观察。

即使你雇佣包工队，你依旧可以选择拥有不同人数的团队。可能在一个团队中，瓦工的数量超过电工。同样，这会是一种补足，并且在建造不止一座房子的时候，会改变工作的整体效率。即使水管工没有太多的任务，在建造过一次房子后，你依旧能让他总是处于忙碌的状态。当包工队无事可做的时候，你是不会给他们钱的；即使每次工作只有那么几个人工作，你还需要负担整个团队的开销。

关于建造例子已经足够说明问题了；这些与线程所做的事情有什么关系呢？好吧，这些问题也会发生在线程上。你需要决定你要使用多少个线程，并且这些线程应该去做什么。还需要决定是使用“能工巧匠”的线程去完成所有的任务，还是使用“专业”线程只去完成一件事情，或将两种方法混合。在使用并发的时候，你需要作出诸多选择来驱动并发，这里的选择会决定代码的性能和清晰度。因此，这里的选择至关重要，所以可以在你设计应用程序的结构时，再作出适当的决定。在本节中，我们将看到很多划分任务的技术，那就先从线程间划分数据开始吧！

###8.1.1 在线程处理前对数据进行划分

###8.1.2 递归划分

###8.1.3 通过任务类型划分工作

##8.2 影响并发代码性能的因素

###8.2.1 有多少个处理器？

###8.2.2 数据争用与乒乓缓存

###8.2.3 伪共享

###8.2.4 如何接近数据？

###8.2.5 过载和频繁的任务切换

##8.3 为多线程性能设计数据结构

###8.3.1 为复杂操作划分数组元素

###8.3.2 其他数据结构中的数据访问模式

##8.4 设计并发代码的注意事项

###8.4.1 并行算法中的异常安全

###8.4.2 可扩展性和Amdahl定律

###8.4.3 使用多线程隐藏延迟

###8.4.4 使用并发提高响应能力

##8.5 在实践中设计并发代码

###8.5.1 并行实现：`std::for_each`

###8.5.2 并行实现：`std::find`

###8.5.3 并行实现：`std::partial_sum`

##8.6 小结