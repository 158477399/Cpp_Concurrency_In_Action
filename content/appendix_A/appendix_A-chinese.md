#附录 A 对C++11语言特性的简要介绍

新的C++标准，不仅带来了对并发的支持，以及其他语言的特性和一些新的标准库。在本附录中，会给出对这些新特性进行简要介绍（这些特性被用在了线程库中，以及这本书的其余部分）。除了thread_local(详见A.8部分)以外，就没有与并发直接相关的了，但是对于多线程代码来说，它们都是很重要。我已经对列表进行的设定，只列出有必要的部分(例如，右值引用)，或能够使代码更容易理解。由于对新特性不熟，对用到某些特性的代码理解起来可能有一些困难；但是，当对这些特性渐渐熟知后，就能很容易的理解代码。由于C++11的应用越来越广泛，这些特性在代码中的使用也将会变越来越普遍。

话不多说，让我们从线程库中的右值引用开始，来熟悉对象之间所有权(线程，锁等等)的转移。

##A.1 右值引用

如果你从事过C++编程，你会对引用比较熟悉，C++的引用允许你为已经存在的对象创建一个新的名字。所有对新引用所做的访问和修改操作，都会影响它的原型。

例如：
```c++
int var=42;
int& ref=var;  // 创建一个var的引用
ref=99;
assert(var==99);  // 原型的值被改变了，因为引用被赋值了
```

目前为止，我们用过的所有引用都是左值引用——对左值的引用。lvalue这个词来自于C语言，指的是可以放在赋值表达式左边的事物——命名的对象，在栈上或者堆上分配的对象，或者其他对象的成员——有明确的内存地址。rvalue这个词也来源于C语言，指的是，可以出现在赋值表达式右侧的对象——例如，文字常量和临时变量。因此，左值引用只能被绑定在左值上而不是右值。不能这样写：

```c++
int& i=42;  // 编译失败
```