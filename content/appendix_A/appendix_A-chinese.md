#附录A 对C++11语言特性的简要介绍

新的C++标准，不仅带来了对并发的支持，以及其他语言的特性和一些新的标准库。在本附录中，会给出对这些新特性进行简要介绍（这些特性被用在了线程库中，以及这本书的其余部分）。除了thread_local(详见A.8部分)以外，就没有与并发直接相关的了，但是对于多线程代码来说，它们都是很重要。我已经对列表进行的设定，只列出有必要的部分(例如，右值引用)，或能够使代码更容易理解。由于对新特性不熟，对用到某些特性的代码理解起来可能有一些困难；但是，当对这些特性渐渐熟知后，就能很容易的理解代码。由于C++11的应用越来越广泛，这些特性在代码中的使用也将会变越来越普遍。

话不多说，让我们从线程库中的右值引用开始，来熟悉对象之间所有权(线程，锁等等)的转移。

##A.1 右值引用

如果你从事过C++编程，你会对引用比较熟悉，C++的引用允许你为已经存在的对象创建一个新的名字。所有对新引用所做的访问和修改操作，都会影响它的原型。

例如：
```c++
int var=42;
int& ref=var;  // 创建一个var的引用
ref=99;
assert(var==99);  // 原型的值被改变了，因为引用被赋值了
```

目前为止，我们用过的所有引用都是左值引用——对左值的引用。lvalue这个词来自于C语言，指的是可以放在赋值表达式左边的事物——命名的对象，在栈上或者堆上分配的对象，或者其他对象的成员——有明确的内存地址。rvalue这个词也来源于C语言，指的是，可以出现在赋值表达式右侧的对象——例如，文字常量和临时变量。因此，左值引用只能被绑定在左值上而不是右值。不能这样写：

```c++
int& i=42;  // 编译失败
```

例如，因为42是一个右值。好吧，这有些假；你可能通常使用下面的方式讲一个右值绑定到一个const左值引用上：

```c++
int const& i = 42;
```

这算是钻了标准的一个空子吧。不过，这种情况我们之前也介绍过，我们通过对左值的const引用创建临时性对象，作为参数传递给函数。其允许隐式转换，所以你可这样写：

```c++
void print(std::string const& s);
print("hello");  //创建了临时std::string对象
```

无论如何，C++11标准介绍了右值引用(*rvalue reference*)，这种方式只能绑定右值，不能绑定左值，其通过两个`&&`来进行声明：

```c++
int&& i=42;
int j=42;
int&& k=j;  // 编译失败
```

因此，可以使用函数重载的方式来确定：函数有左值或右值为参数的时候，看其能否被同名且对应参数为左值或有值引用的函数所重载。

其基础就是C++11新添的语义——移动语义(*move semantics*)。

###A.1.1 移动语义

###A.1.2 右值引用和函数模板

##A.2 删除函数

##A.3 默认函数

##A.4 常量表达式函数

###A.4.1 常量表达式和自定义类型

###A.4.2 常量表达式对象

###A.4.3 常量表达式函数的要求

###A.4.4 常量表达式和模板

##A.5 Lambda函数

###A.5.1 引用本地变量的Lambda函数

##A.6 可变参数模板

###A.6.1 扩展参数包

##A.7 自动推导变量类型

##A.8 thread_local变量

##A.9 小结