#附录A 对C++11语言特性的简要介绍

新的C++标准，不仅带来了对并发的支持，以及其他语言的特性和一些新的标准库。在本附录中，会给出对这些新特性进行简要介绍（这些特性被用在了线程库中，以及这本书的其余部分）。除了thread_local(详见A.8部分)以外，就没有与并发直接相关的了，但是对于多线程代码来说，它们都是很重要。我已经对列表进行的设定，只列出有必要的部分(例如，右值引用)，或能够使代码更容易理解。由于对新特性不熟，对用到某些特性的代码理解起来可能有一些困难；但是，当对这些特性渐渐熟知后，就能很容易的理解代码。由于C++11的应用越来越广泛，这些特性在代码中的使用也将会变越来越普遍。

话不多说，让我们从线程库中的右值引用开始，来熟悉对象之间所有权(线程，锁等等)的转移。

##A.1 右值引用

如果你从事过C++编程，你会对引用比较熟悉，C++的引用允许你为已经存在的对象创建一个新的名字。所有对新引用所做的访问和修改操作，都会影响它的原型。

例如：
```c++
int var=42;
int& ref=var;  // 创建一个var的引用
ref=99;
assert(var==99);  // 原型的值被改变了，因为引用被赋值了
```

目前为止，我们用过的所有引用都是左值引用——对左值的引用。lvalue这个词来自于C语言，指的是可以放在赋值表达式左边的事物——命名的对象，在栈上或者堆上分配的对象，或者其他对象的成员——有明确的内存地址。rvalue这个词也来源于C语言，指的是，可以出现在赋值表达式右侧的对象——例如，文字常量和临时变量。因此，左值引用只能被绑定在左值上而不是右值。不能这样写：

```c++
int& i=42;  // 编译失败
```

例如，因为42是一个右值。好吧，这有些假；你可能通常使用下面的方式讲一个右值绑定到一个const左值引用上：

```c++
int const& i = 42;
```

这算是钻了标准的一个空子吧。不过，这种情况我们之前也介绍过，我们通过对左值的const引用创建临时性对象，作为参数传递给函数。其允许隐式转换，所以你可这样写：

```c++
void print(std::string const& s);
print("hello");  //创建了临时std::string对象
```

无论如何，C++11标准介绍了右值引用(*rvalue reference*)，这种方式只能绑定右值，不能绑定左值，其通过两个`&&`来进行声明：

```c++
int&& i=42;
int j=42;
int&& k=j;  // 编译失败
```

因此，可以使用函数重载的方式来确定：函数有左值或右值为参数的时候，看其能否被同名且对应参数为左值或有值引用的函数所重载。

其基础就是C++11新添的语义——移动语义(*move semantics*)。

###A.1.1 移动语义

右值通常都是临时的，所以可以随意修改；如果你知道函数的某个参数是一个右值，你可以将其看作为一个临时存储，或就算“窃取”其内容，也不会不影响程序的正确性。这就意味着，比起拷贝右值参数的内容，不如移动其内容。动态数组比较大的时候，这样做能节省很多内存分配，也提供了更多的优化空间。试想，一个函数以`std::vector<int>`作为一个参数，就需要将其拷贝进来，而不对原始的数据做任何操作。C++03/98的办法是，将这个参数作为一个左值的const引用传入，然后做内部拷贝：

```c++
void process_copy(std::vector<int> const& vec_)
{
  std::vector<int> vec(vec_);
  vec.push_back(42);
}
```

这就允许函数能以左值或右值的形式进行传递，不过任何情况下都是通过拷贝来完成的。如果使用右值引用的函数版本来重载这个函数，就能避免在传入右值的时候，函数会进行内部拷贝的过程，因为你知道你可以任意的对原始值进行修改：

```c++
void process_copy(std::vector<int> && vec)
{
  vec.push_back(42);
}
```

现在，如果这个问题存在于类的构造函数中，你可以窃取内部右值，在新的实例中使用。可以参考一下清单中的例子(默认构造函数会分配很大一块内存，其会在析构函数中释放)。

清单A.1 使用移动构造函数的类
```c++
class X
{
private:
  int* data;

public:
  X():
    data(new int[1000000])
  {}

  ~X()
  {
    delete [] data;
  }

  X(const X& other):  // 1
   data(new int[1000000])
  {
    std::copy(other.data,other.data+1000000,data);
  }
  
  X(X&& other):  // 2
    data(other.data)
  {
    other.data=nullptr;
  }
};
```

一般情况下，拷贝构造函数①都是这么定义：分配一块新内存，然后将数据拷贝进去。不过，你现在有了一个新的构造函数，可以接受右值引用来获取老数据②。这就是移动构造函数。在这个例子中，你只是将指针拷贝到数据中，并且将other以空指针的形式，实例留在了新实例中；使用右值里创建变量，就能避免了空间和时间上的多余消耗。

X类(清单A.1)中的移动构造函数，仅作为一次优化；不过在其他例子中，有些类型的构造函数只支持移动构造函数，而不知道拷贝构造函数。例如，智能指针`std::unique_ptr<>`的非空实例中，只有这个指针指向其对象，所以拷贝函数在这里就不能用了(如果使用拷贝函数，就会有两个`std::unique_ptr<>`指向该对象，这是不满足`std::unique_ptr<>`定义的)。不过，移动构造函数允许对指针的所有权，在实例之间进行传递，并且允许`std::unique_ptr<>`像一个带有返回值的函数一样使用——指针的转移是通过移动，而非拷贝。

如果你已经知道，某个变量在之后就不会在用到了，这时候可以选择显示的移动，你可以使用`static_cast<X&&>`将对应变量转换为右值，或者通过调用`std::move()`函数来做这件事：

```c++
X x1;
X x2=std::move(x1);
X x3=static_cast<X&&>(x2);
```

当你想要将参数值，不通过拷贝，转化为本地变量，或成员变量时，就可以使用这个办法；虽然右值引用参数绑定了右值，不过在函数内部，其会当做左值来处理：

```c++
void do_stuff(X&& x_)
{
  X a(x_);  // 拷贝
  X b(std::move(x_));  // 移动
}
do_stuff(X());  // ok，右值绑定到右值引用上
X x;
do_stuff(x);  // 错误，左值不能绑定到右值引用上
```

移动语义在线程库中用的比较广泛，对于无拷贝操作的时候，对数据进行转移，还有作为一种优化方式，避免对将要被销毁的变量，进行额外的拷贝。你已经在2.2节中看到，使用`std::move()`来转移`std::unique_ptr<>`实例的到一个新创建的线程中；在2.3节中，我们也了解了使用移动语义在`std:thread`的实例间，转移线程的所有权。

`std::thread`、`std::unique_lock<>`、`std::future<>`、 `std::promise<>`和`std::packaged_task<>`都不能拷贝，不过这些类都有移动构造函数，能让相关资源在实例中进行传递，并且其也支持用一个函数将值进行返回。`std::string`和`std::vector<>`都是可以拷贝的，不过它们也有移动构造函数和移动赋值操作符，就是为了避免拷贝从右值拷贝大量的数据。

C++标准库不会将一个对象显示的转移到另一个对象中，除非要将其销毁的时候，或对其赋值的时候(拷贝和移动的操作很相似)。不过，实践中表现良好，移动能保证类中的所有状态保持不变。一个`std::thread`实例可以作为移动源，转移到新创建(以默认构造方式)的`std::thread`实例中。还有，`std::string`可以通过移动原始数据进行构造，并且保留原始数据正确的状态，不过不能保证的是原始数据中该状态是否正确(这样更具字符串的长度或字符的数量决定)。

###A.1.2 右值引用和函数模板

##A.2 删除函数

##A.3 默认函数

##A.4 常量表达式函数

###A.4.1 常量表达式和自定义类型

###A.4.2 常量表达式对象

###A.4.3 常量表达式函数的要求

###A.4.4 常量表达式和模板

##A.5 Lambda函数

###A.5.1 引用本地变量的Lambda函数

##A.6 可变参数模板

###A.6.1 扩展参数包

##A.7 自动推导变量类型

##A.8 thread_local变量

##A.9 小结