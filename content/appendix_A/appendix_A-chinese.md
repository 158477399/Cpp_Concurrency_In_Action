#附录A 对C++11语言特性的简要介绍

新的C++标准，不仅带来了对并发的支持，以及其他语言的特性和一些新的标准库。在本附录中，会给出对这些新特性进行简要介绍（这些特性被用在了线程库中，以及这本书的其余部分）。除了thread_local(详见A.8部分)以外，就没有与并发直接相关的了，但是对于多线程代码来说，它们都是很重要。我已经对列表进行的设定，只列出有必要的部分(例如，右值引用)，或能够使代码更容易理解。由于对新特性不熟，对用到某些特性的代码理解起来可能有一些困难；但是，当对这些特性渐渐熟知后，就能很容易的理解代码。由于C++11的应用越来越广泛，这些特性在代码中的使用也将会变越来越普遍。

话不多说，让我们从线程库中的右值引用开始，来熟悉对象之间所有权(线程，锁等等)的转移。

##A.1 右值引用

如果你从事过C++编程，你会对引用比较熟悉，C++的引用允许你为已经存在的对象创建一个新的名字。所有对新引用所做的访问和修改操作，都会影响它的原型。

例如：
```c++
int var=42;
int& ref=var;  // 创建一个var的引用
ref=99;
assert(var==99);  // 原型的值被改变了，因为引用被赋值了
```

目前为止，我们用过的所有引用都是左值引用——对左值的引用。lvalue这个词来自于C语言，指的是可以放在赋值表达式左边的事物——命名的对象，在栈上或者堆上分配的对象，或者其他对象的成员——有明确的内存地址。rvalue这个词也来源于C语言，指的是，可以出现在赋值表达式右侧的对象——例如，文字常量和临时变量。因此，左值引用只能被绑定在左值上而不是右值。不能这样写：

```c++
int& i=42;  // 编译失败
```

例如，因为42是一个右值。好吧，这有些假；你可能通常使用下面的方式讲一个右值绑定到一个const左值引用上：

```c++
int const& i = 42;
```

这算是钻了标准的一个空子吧。不过，这种情况我们之前也介绍过，我们通过对左值的const引用创建临时性对象，作为参数传递给函数。其允许隐式转换，所以你可这样写：

```c++
void print(std::string const& s);
print("hello");  //创建了临时std::string对象
```

无论如何，C++11标准介绍了右值引用(*rvalue reference*)，这种方式只能绑定右值，不能绑定左值，其通过两个`&&`来进行声明：

```c++
int&& i=42;
int j=42;
int&& k=j;  // 编译失败
```

因此，可以使用函数重载的方式来确定：函数有左值或右值为参数的时候，看其能否被同名且对应参数为左值或有值引用的函数所重载。

其基础就是C++11新添的语义——移动语义(*move semantics*)。

###A.1.1 移动语义

右值通常都是临时的，所以可以随意修改；如果你知道函数的某个参数是一个右值，你可以将其看作为一个临时存储，或就算“窃取”其内容，也不会不影响程序的正确性。这就意味着，比起拷贝右值参数的内容，不如移动其内容。动态数组比较大的时候，这样做能节省很多内存分配，也提供了更多的优化空间。试想，一个函数以`std::vector<int>`作为一个参数，就需要将其拷贝进来，而不对原始的数据做任何操作。C++03/98的办法是，将这个参数作为一个左值的const引用传入，然后做内部拷贝：

```c++
void process_copy(std::vector<int> const& vec_)
{
  std::vector<int> vec(vec_);
  vec.push_back(42);
}
```

这就允许函数能以左值或右值的形式进行传递，不过任何情况下都是通过拷贝来完成的。如果使用右值引用的函数版本来重载这个函数，就能避免在传入右值的时候，函数会进行内部拷贝的过程，因为你知道你可以任意的对原始值进行修改：

```c++
void process_copy(std::vector<int> && vec)
{
  vec.push_back(42);
}
```

现在，如果这个问题存在于类的构造函数中，你可以窃取内部右值，在新的实例中使用。可以参考一下清单中的例子(默认构造函数会分配很大一块内存，其会在析构函数中释放)。

清单A.1 使用移动构造函数的类
```c++
class X
{
private:
  int* data;

public:
  X():
    data(new int[1000000])
  {}

  ~X()
  {
    delete [] data;
  }

  X(const X& other):  // 1
   data(new int[1000000])
  {
    std::copy(other.data,other.data+1000000,data);
  }
  
  X(X&& other):  // 2
    data(other.data)
  {
    other.data=nullptr;
  }
};
```

一般情况下，拷贝构造函数①都是这么定义：分配一块新内存，然后将数据拷贝进去。不过，你现在有了一个新的构造函数，可以接受右值引用来获取老数据②。这就是移动构造函数。在这个例子中，你只是将指针拷贝到数据中，并且将other以空指针的形式，实例留在了新实例中；使用右值里创建变量，就能避免了空间和时间上的多余消耗。

X类(清单A.1)中的移动构造函数，仅作为一次优化；不过在其他例子中，有些类型的构造函数只支持移动构造函数，而不知道拷贝构造函数。例如，智能指针`std::unique_ptr<>`的非空实例中，只有这个指针指向其对象，所以拷贝函数在这里就不能用了(如果使用拷贝函数，就会有两个`std::unique_ptr<>`指向该对象，这是不满足`std::unique_ptr<>`定义的)。不过，移动构造函数允许对指针的所有权，在实例之间进行传递，并且允许`std::unique_ptr<>`像一个带有返回值的函数一样使用——指针的转移是通过移动，而非拷贝。

如果你已经知道，某个变量在之后就不会在用到了，这时候可以选择显示的移动，你可以使用`static_cast<X&&>`将对应变量转换为右值，或者通过调用`std::move()`函数来做这件事：

```c++
X x1;
X x2=std::move(x1);
X x3=static_cast<X&&>(x2);
```

当你想要将参数值，不通过拷贝，转化为本地变量，或成员变量时，就可以使用这个办法；虽然右值引用参数绑定了右值，不过在函数内部，其会当做左值来处理：

```c++
void do_stuff(X&& x_)
{
  X a(x_);  // 拷贝
  X b(std::move(x_));  // 移动
}
do_stuff(X());  // ok，右值绑定到右值引用上
X x;
do_stuff(x);  // 错误，左值不能绑定到右值引用上
```

移动语义在线程库中用的比较广泛，对于无拷贝操作的时候，对数据进行转移，还有作为一种优化方式，避免对将要被销毁的变量，进行额外的拷贝。你已经在2.2节中看到，使用`std::move()`来转移`std::unique_ptr<>`实例的到一个新创建的线程中；在2.3节中，我们也了解了使用移动语义在`std:thread`的实例间，转移线程的所有权。

`std::thread`、`std::unique_lock<>`、`std::future<>`、 `std::promise<>`和`std::packaged_task<>`都不能拷贝，不过这些类都有移动构造函数，能让相关资源在实例中进行传递，并且其也支持用一个函数将值进行返回。`std::string`和`std::vector<>`都是可以拷贝的，不过它们也有移动构造函数和移动赋值操作符，就是为了避免拷贝从右值拷贝大量的数据。

C++标准库不会将一个对象显示的转移到另一个对象中，除非要将其销毁的时候，或对其赋值的时候(拷贝和移动的操作很相似)。不过，实践中表现良好，移动能保证类中的所有状态保持不变。一个`std::thread`实例可以作为移动源，转移到新创建(以默认构造方式)的`std::thread`实例中。还有，`std::string`可以通过移动原始数据进行构造，并且保留原始数据正确的状态，不过不能保证的是原始数据中该状态是否正确(这样更具字符串的长度或字符的数量决定)。

###A.1.2 右值引用和函数模板

不过在使用右值引用作为函数模板的参数时，还是之前的用法有些不同的：如果模板函数参数以右值引用作为一个模板参数，当在对应位置提供左值的时候，模板会自动将其类型认定为左值引用；当提供右值的时候，其会当做普通数据使用。这可能有些口语化，那就来看几个例子吧。

考虑一下下面的函数模板：

```c++
template<typename T>
void foo(T&& t)
{}
```

当你随后传入一个右值，T的类型将被推导为：

```c++
foo(42);  // foo<int>(42)
foo(3.14159);  // foo<double><3.14159>
foo(std::string());  // foo<std::string>(std::string())
```

不过，在向foo传入左值的时候，T会比推导为一个左值引用：

```c++
int i = 42;
foo(i);  // foo<int&>(i)
```

因为函数参数声明为T&&，所以就是引用的引用，可以视为是原始的引用类型。那么foo<int&>()就相当于：

```c++
foo<int&>(); // void foo<int&>(int& t);
```

这就允许一个函数模板可以即接受左值，又可以接受右值参数；这种方式已经被`std::thread`的构造函数所使用(2.1节和2.2节)，所以能够将可调用对象移动到内部存储，而非当参数是右值的时候进行拷贝。

##A.2 删除函数

有时让类去做拷贝是没有意义的。`std::mutex`就是一个最好的例子——拷贝一个互斥量，有什么意义呢？`std::unique_lock<>`是另一个例子——一个实例只能拥有一个锁。如果要复制，那拷贝的那个实例也能获取相同的锁，这样`std::unique_lock<>`就没有存在的意义了。在实例中转移所有权(A.1.2节)，是有意义的，其并不是使用的拷贝。当然其他例子就不一一列举了。

通常为了避免进行拷贝操作，会将拷贝构造函数和拷贝赋值操作符声明为私有成员，并且不进行实现。如果对实例进行拷贝，将会引起编译错误；如果有其他成员函数或友元函数想要拷贝一个实例，那将会引起链接错误(因为缺少实现)：

```c++
class no_copies
{
public:
  no_copies(){}
private:
  no_copies(no_copies const&);  // 无实现
  no_copies& operator=(no_copies const&);  // 无实现
};

no_copies a;
no_copies b(a);  // 编译错误
```

在C++11中，委员会意识到这种情况，但是没有意识到其会带来攻击性。因此，委员会提供了更多的通用机制，以用于其他情况：你可以通过添加`= delete`将一个函数声明为删除函数。no_copise类就可以写为：

```c++
class no_copies
{
public:
  no_copies(){}
  no_copies(no_copies const&) = delete;
  no_copies& operator=(no_copies const&) = delete;
};
```

这样的描述要比之前的代码更加清晰。这也会允许编译器提供更多的错误信息描述，当有成员函数想要执行拷贝操作的时候，可将连接错误转移到编译时。

当将拷贝构造和拷贝赋值操作删除后，你还需要显式写一个移动构造函数和移动赋值操作符，与`std::thread`和`std::unique_lock<>`一样，你的类就是只移动的。下面清单中的例子，就展示了一个只移动的类。

清单A.2 一个简单的只移动类型
```c++
class move_only
{
  std::unique_ptr<my_class> data;
public:
  move_only(const move_only&) = delete;
  move_only(move_only&& other):
    data(std::move(other.data))
  {}
  move_only& operator=(const move_only&) = delete;
  move_only& operator=(move_only&& other)
  {
    data=std::move(other.data);
    return *this;
  }
};

move_only m1;
move_only m2(m1);  // 错误，拷贝构造声明为“已删除”
move_only m3(std::move(m1));  // OK，找到移动构造函数
```

只移动对象可以作为函数的参数进行传递，并且从函数中返回，不过当你想要移动左值，你通常需要显式的使用`std::move()`或`static_cast<T&&>`。

你可以为任意函数添加`= delete`说明符，添加后就说明这些函数是不能使用的。当然，还可以用于很多的地方；删除函数可以以正常的方式参与重载解析，并且如果被使用，也只会引起编译错误。这种方式可以用来删除特定的重载。比如，当你的函数以short作为参数，为了避免扩展为int类型，你可以写出重载函数(以int为参数)的声明，然后添加删除说明符：

```c++
void foo(short);
void foo(int) = delete;
```

现在，任何向foo函数传递int类型参数都会残生一个编译错误，不过调用者可以显式的将其他类型转化为short：

```c++
foo(42);  // 错误，int重载声明已经删除
foo((short)42);  // OK
```

##A.3 默认函数

删除函数可以让你对一个显示声明的函数不进行实现，默认函数就完全相反：其会让编译器为你创建函数实现，通常都是“默认”实现。当然，这些函数你可以直接使用，它们都会自动生成：默认构造函数，析构函数，拷贝构造函数，移动构造函数，拷贝赋值操作符和移动赋值操作符。

为什么要这样做呢？这里列出一些原因：

- 改变函数的可访问性——编译器生成的默认函数通常都是声明为public。如果你想让其为protected或private成员，你必须自己去实现它们。通过将其声明为默认，你可以让编译器来帮助你实现函数和改变访问级别。

- 作为文档——当编译器生成版本已经足够使用，那么将其进行显式声明就利于你或其他人在之后对这段代码的阅读，这会让代码看起来很清晰。

- 让编译器自动生成函数，当这些函数没有单独实现的时候——通常会由默认构造函数来做这件事，如果用户没有定义构造函数，编译器将会生成一个。当你需要自定一个拷贝构造函数时(假设)，如果将其声明为默认，你也可以获得编译器为你实现的拷贝构造函数。

- 让编译器生成虚析构函数。

- 声明一个特殊版本的拷贝构造函数，比如：参数类型是非const引用，而不是const引用。

- 利用编译生成函数的特殊性质，如果你提供了对应的函数，其将会失效——会在后面具体讲解。

就像删除函数是在函数后面添加`= delete`一样，默认函数需要在函数后面添加`= default`，例如：

```c++
class Y
{
private:
  Y() = default;  // 改变访问级别
public:
  Y(Y&) = default;  // 以非const引用作为参数
  T& operator=(const Y&) = default; // 作为文档的形式，声明为默认函数
protected:
  virtual ~Y() = default;  // 改变访问级别，以及添加虚函数标签
};
```

之前编译器生成函数都有独特的特性，这是用户定义版本所不具备的。最大的区别就是编译器生成的函数都是简单的。这里列出了几点重要的特性：

- 对象具有简单的拷贝构造函数，拷贝赋值操作符和析构函数，其都能通过memcpy或memmove进行拷贝。

- 字面类型用于constexpr函数(可见A.4节)，必须有简单的构造，拷贝构造和析构函数。

- 类的默认构造，拷贝，拷贝赋值操作符合析构函数也可以用在，一个已有构造和析构函数的用户定义的联合体内。

- 类的简单拷贝赋值操作符可以使用`std::atomic<>`类型模板(见5.2.6节)，就是为了某种类型的值提供原子操作。

仅添加`= default`不会让函数变得简单——如果类还支持其他相关标准的函数，那这个函数就是简单的——不过用户显式的实现就不会让这些函数变简单。

第二个区别在于，编译器生成函数和用户提供的函数等价，也就是类中无用户提供的构造函数可以看作为一个aggregate，并且可以通过聚合初始化函数进行初始化：

```c++
struct aggregate
{
  aggregate() = default;
  aggregate(aggregate const&) = default;
  int a;
  double b;
};
aggregate x={42,3.141};
```

在这个例子中，x.a被42初始化，x.b被3.141初始化。

第三个不同点，编译器生成的函数只适用于构造函数，换句话说，只适用于符合某些标准的默认构造函数。

```c++
struct X
{
  int a;
};
```

如果你创建了一个X的实例，而未初始化，其中int(a)将会被默认初始化。如果对象有静态存储过程，那么a将会被初始化为0；另外，当a没有赋值的时候，其不定值可能会触发未定义行为：

```c++
X x1;  // x1.a的值不明确
```

另外，当你使用显示调用构造函数的方式对X进行初始化，那么a就会被初始化为0：

```c++
X x2 = X();  // x2.a == 0
```

这种奇怪的属性会扩展到基础类和成员函数中。当类的默认构造函数是由编译器提供，并且一些数据成员和基类都是有编译器提供默认构造函数时，基类的数据成员和该类中的数据成员都是内置类型的时候，其值要不就是不确定的，要不就是被初始化为0，这与默认构造函数是否能被显式调用有关。

虽然这条规则令人困惑，并且容易造成错误，不过其也很有用，并且当你编写构造函数的时候，就不会用到这个特性；数据成员，通常都可以被初始化(因为你为其指定了一个值，或调用了显式构造函数)，或不会被初始化(因为不需要)：

```c++
X::X():a(){}  // a == 0
X::X():a(42){}  // a == 2
X::X(){}  // 1
```

在第三个例子中①，你省略了对a的初始化，X中a就是一个未被初始化的非静态实例，被初始化的X实例都会有静态存储过程。

在通常的情况下，如果手动写了其他构造函数，编译器就不会在为你生成默认构造函数了。所以，当你想要自己写一个的时候，就意味着你放弃了这种奇怪的初始化属性。不过，将构造函数显示声明成默认的，你就能强制编译器为你生成一个默认构造函数了，并且刚才说的那种特性将会保留：

```c++
X::X() = default;  // 应用默认初始化规则
```

这种特性用于原子变量(见5.2节)，默认构造函数显式为默认的。他们的初始值通常都是没有定义的，除非他们具有(a)一个静态存储的过程(静态初始化为0)，或(b)显式调用默认构造函数，将成员初始化为0，亦或(c)指定一个特殊的值。注意，在这种情况下的原子变量，为了允许静态初始化过程，构造函数会通过一个声明为constexpr(见A.4节)的值为原子变量进行初始化。

##A.4 常量表达式函数

整型字面值，例如42，就是常量表达式。所以，简单的数学表达式，例如，23x2-4。可以使用其来初始化const整型变量，然后将const整型变量作为新表达的一部分：

```c++
const int i=23;
const int two_i=i*2;
const int four=4;
const int forty_two=two_i-four;
```

处理使用常量表达式创建变量也可用在其他常量表达式中，有些事情只能用常量表达式去做：

- 指定数组边界：
```c++
int bounds=99;
int array[bounds];  // 错误，bounds不是一个常量表达式
const int bounds2=99;
int array2[bounds2];  // 正确，bounds2是一个常量表达式
```

- 指定非类型模板参数的值：
```c++
template<unsigned size>
struct test
{};
test<bounds> ia;  // 错误，bounds不是一个常量表达式
test<bounds2> ia2;  // 正确，bounds2是一个常量表达式
```

- 可以对类中static const整型成员变量进行初始化：
```c++
class X
{
  static const int the_answer=forty_two;
};
```

- 可以对内置类型进行初始化，或可用于静态初始化集合：
```c++
struct my_aggregate
{
  int a;
  int b;
};
static my_aggregate ma1={forty_two,123};  // 静态初始化
int dummy=257;
static my_aggregate ma2={dummy,dummy};  // 动态初始化
```

- 静态初始化可以避免初始化顺序和条件变量的问题。

这些都不是新添加的——你可以在1998版本的C++标准中找到对应上面实例的条款。不过，在新标准中常量表达式进行了扩展，并添加了新的关键字`constexpr`。

关键字`constexpr`会对功能进行修改。当参数和函数返回类型符合要求，并且实现很简单，那么这样的函数就能够被声明为`constexpr`，这样函数可以当做常数表达式来使用：

```c++
constexpr int square(int x)
{
  return x*x;
}
int array[square(5)];
```

在这个例子中，array有25个元素，因为square函数的声明为`constexpr`。当然，这种方式可以被当做常数表达式来使用，不以为着什么情况下都是能够自动转换为常数表达式的：

```c++
int dummy=4;
int array[square(dummy)];  // 错误，dummy不是常数表达式
```

例子中，dummy不是常数表达式，所以square(dummy)也不是——其就是一个普通函数调用——所以其不能用来指定array的边界。

###A.4.1 常量表达式和自定义类型

目前为止的例子都是以内置int型展开的。不过，在新C++标准库中，对于满足字面类型要求的任何类型，都可以用常量表达式来表示。要想划分到字面类型中，需要满足一下几点：

- 一般的拷贝构造函数。

- 一般的析构函数。

- 所有成员变量都是非静态的，且基类需要是一个一般类型。

- 必须具有一个一般的默认构造函数，或一个constexpr构造函数。

后面会来看一下constexpr构造函数。现在，我们先将注意力集中在默认构造函数上，就像下面清单中的CX类一样。

清单A.3（一般)默认构造函数的类
```c++
class CX
{
private:
  int a;
  int b;
public:
  CX() = default;  // 1
  CX(int a_, int b_):  // 2
    a(a_),b(b_)
  {}
  int get_a() const
  {
    return a;
  }
  int get_b() const
  {
    return b;
  }
  int foo() const
  {
    return a+b;
  }
};
```

注意，这里我们显式的声明了默认构造函数①(见A.3节)，是为了保存用户定义的构造函数②。因此，这种类型符合字面类型的要求，就可以将其用在常量表达式中了。你可以提供一个constexpr函数来创建一个实例，例如：

```c++
constexpr CX create_cx()
{
  return CX();
}
```

也可以创建一个简单的constexpr函数来拷贝参数：

```
constexpr CX clone(CX val)
{
  return val;
}
```

不过，constexpr函数只有其他constexpr函数可以进行调用。在CX类中声明成员函数和构造函数为constexpr：

```c++
class CX
{
private:
  int a;
  int b;
public:
  CX() = default;
  constexpr CX(int a_, int b_):
    a(a_),b(b_)
  {}
  constexpr int get_a() const  // 1
  {
    return a;
  }
  constexpr int get_b()  // 2
  {
    return b;
  }
  constexpr int foo()
  {
    return a+b;
  }
};
```

注意，现在const对于get_a()①来说就是多余的，因为其暗示在使用constexpr.get_b()就已经是是const了，所以const描述符在这里会被忽略。这样就允许更多复杂的constexpr函数存在：

```c++
constexpr CX make_cx(int a)
{
  return CX(a,1);
}
constexpr CX half_double(CX old)
{
  return CX(old.get_a()/2,old.get_b()*2);
}
constexpr int foo_squared(CX val)
{
  return square(val.foo());
}
int array[foo_squared(half_double(make_cx(10)))];  // 49个元素
```

这里的函数都很有趣，如果你想要计算数组的边界或是一个整型常量，你就需要使用这种方式。最大的好处是常量表达式和constexpr函数会设计到用户定义类型的对象，可以使用这些函数，对这些对象进行初始化。因为常量表达式的初始化过程是静态初始化，所以这种方式就能避免条件竞争和初始化顺序的问题：

```c++
CX si=half_double(CX(42,19));  // 静态初始化
```

这也包含构造函数。当构造函数被声明为constexpr，并且构造函数参数是常量表达式，那么初始化过程就是常数初始化，可能作为静态初始化的一部分。随着并发的发展，这也C++11标准中的一个重要改变：允许用户定义构造函数可以进行静态初始化，就可以在初始化的时候避免条件竞争，因为静态过程能保证初始化过程在代码运行前进行。

特别是关于`std::mutex`(见3.2.1节)，或`std::atomic<>`(见5.2.6节)，当你可能想要使用一个全局实例来同步其他变量的访问，这样同步访问就能避免条件竞争的发生。在构造函数中，互斥量产生条件竞争是不可能的，因此对于`std::mutex`的默认构造函数就应该被声明为constexpr，就是为了保证互斥量初始化过程是一个静态初始化过程的一部分。

###A.4.2 常量表达式对象

###A.4.3 常量表达式函数的要求

###A.4.4 常量表达式和模板

##A.5 Lambda函数

###A.5.1 引用本地变量的Lambda函数

##A.6 可变参数模板

###A.6.1 扩展参数包

##A.7 自动推导变量类型

##A.8 thread_local变量

##A.9 小结