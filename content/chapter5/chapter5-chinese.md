#第五章 C++内存模型和原子类型操作

**本章主要内容**

>C++11内存模型详解<br>
>C++标准库提供的原子类型<br>
>如何操作各种原子类型<br>
>原子操作如何为线程提供同步功能<br>

C++11标准中，有一个十分重要特性，常被程序员们所忽略。它不是一个新的语法特性，也不是新的库工具，它就是新的多线程(感知)内存模型。没有内存模型明确的定义基本部件应该如何工作的话，之前介绍的那些工具就无法正常工作。当然，为什么大多数程序员都没有注意到它呢？当你使用互斥量去保护你的数据和条件变量，或者是“期望”上的信号事件，对于互斥量*为什么*能起到这样作用，大多数人不会去关心。只有当你试图去“接触硬件”，你才能详细的了解到内存模型是怎么起作用的。

C++是一个系统级别的编程语言。标准委员会的目标之一就是不需要比C++还要底层的高级语言。C++应该向程序员提供足够的灵活性，去做想要做的事情时，没有语言上的障碍；当需要的时候，可以让他们“接触硬件”。原子类型和操作就允许“接触硬件”，提供底层级别的同步操作，通常会将常规指令数缩减到1~2个CPU指令。

在本章，我们将讨论内存模型的基本知识，而后在了解一下原子类型和操作，最后了解与原子类型操作相关的各种同步。这个过程可能会比较复杂：除非你已经打算使用原子操作(比如，第7章的无锁数据结构)同步你的代码，要不你就没有必要了解过多的细节。

现在让我们轻松愉快的来看一下有关内存模型的基本知识。

##5.1 内存模型基础

###5.1.1 对象和内存位置

###5.1.2 对象，内存位置和并发

###5.1.3 修改顺序