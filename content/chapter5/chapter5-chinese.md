#第五章 C++内存模型和原子类型操作

**本章主要内容**

>C++11内存模型详解<br>
>C++标准库提供的原子类型<br>
>如何操作各种原子类型<br>
>原子操作如何为线程提供同步功能<br>

C++11标准中，有一个十分重要特性，常被程序员们所忽略。它不是一个新的语法特性，也不是新的库工具，它就是新的多线程(感知)内存模型。没有内存模型明确的定义基本部件应该如何工作的话，之前介绍的那些工具就无法正常工作。当然，为什么大多数程序员都没有注意到它呢？当你使用互斥量去保护你的数据和条件变量，或者是“期望”上的信号事件，对于互斥量*为什么*能起到这样作用，大多数人不会去关心。只有当你试图去“接触硬件”，你才能详细的了解到内存模型是怎么起作用的。

C++是一个系统级别的编程语言。标准委员会的目标之一就是不需要比C++还要底层的高级语言。C++应该向程序员提供足够的灵活性，去做想要做的事情时，没有语言上的障碍；当需要的时候，可以让他们“接触硬件”。原子类型和操作就允许“接触硬件”，提供底层级别的同步操作，通常会将常规指令数缩减到1~2个CPU指令。

在本章，我们将讨论内存模型的基本知识，而后在了解一下原子类型和操作，最后了解与原子类型操作相关的各种同步。这个过程可能会比较复杂：除非你已经打算使用原子操作(比如，第7章的无锁数据结构)同步你的代码，要不你就没有必要了解过多的细节。

现在让我们轻松愉快的来看一下有关内存模型的基本知识。

##5.1 内存模型基础

这里从两方面来讲内存模型：一方面是基本结构，这个结构奠定了与内存相关的事物；另一方面就是并发。基本结构对于并发也是很重要的，特别是当你阅读到底层原子操作的时候，所以我将会从基本结构讲起。在C++中，它与所有的对象和内存位置有关。

###5.1.1 对象和内存位置

在一个C++程序中的所有数据都是由对象(objects)构成。这不是说你可以创建一个int的衍生类，或者在基本类型中存在成员函数，亦或在Smalltalk和Ruby语言下讨论程序时，就意味着“一切都是对象”。这仅仅是对C++数据构建块的一个声明。C++标准定义类对象为“存储区域”，但对象还是可以将自己的特性赋予其他对象，比如，类型和生命周期。

像这样的对象是简单基本类型，比如，int或float；当然，也有用户定义类的实例。一些对象(比如，数组，衍生类的实例，无静态数据成员的类的实现)拥有子对象，但是其他对象就没有。

无论对象是怎么样的一个类型，一个对象都会存储在一个或多个内存位置上。每一个内存位置不是一个标量类型的对象，就是一个标量类型的子对象，比如，unsigned short、my_class*或序列中的相邻位域。当你使用位域，就需要注意：虽然相邻位域中是不同的对象，但仍然视其为相同的内存位置。如图5.1所示，将一个struct分解为多个对象，并且展示了每个对象的内存位置。

![](https://raw.githubusercontent.com/xiaoweiChen/Cpp_Concurrency_In_Action/master/images/chapter5/5-1.png)

图5.1 分解一个struct，展示不同对象的内存位置

首先，完整的struct是一个有多个子对象(每一个成员变量)组成的对象。位域bf1和bf2共享同一个内存位置(int是4字节、32位类型)，并且`std::string`类型的对象s由内部多个内存位置组成，但是其他的每个成员都拥有自己的内存位置。注意，位域宽度为0的bf3是如何与bf4分离，并拥有各自的内存位置的。(译者注：图中bf3是一个错误展示，在C++和C中规定，宽度为0的一个未命名位域强制下一位域对齐到其下一type边界，其中type是该成员的类型。这里使用命名变量为0的位域，可能只是想展示其与bf4是如何分离的。有关位域的更多可以参考[MSDN](https://msdn.microsoft.com/zh-cn/library/ewwyfdbe.aspx)、[wiki](http://en.wikipedia.org/wiki/Bit_field)的页面)。

有四条比较重要的事情需要我们记着：<br>
1. 每一个变量都是一个对象，包括作为其成员变量的其他对象。<br>
2. 每个对象都占有至少一个内存位置。<br>
3. 如int和char的基本类型都有确定的内存位置(无论类型大小如何，即使他们是相邻的，或是数组的一部分)。<br>
4. 相邻位域是相同位域内的一部分。<br>

我确定你会好奇，这些在并发中有什么作用，那么下面就让我们来看一看。

###5.1.2 对象、内存位置和并发

这部分对于C++的多线程应用来说是至关重要的：所有东西都在内存位置上。当两个线程访问不同(*separate*)的内存位置，就不会存在任何问题，一切都工作顺利。另一种情况，当两个线程访问同一(*same*)个内存位置，你就需要小心了。如果没有线程更新内存位置上的数据，那还好；制度数据不需要保护或同步。当有线程对内存位置上的数据进行修改，那就有可能会产生条件竞争，如第3章所述的那样。

为了避免条件竞争，在两个线程间就需要有执行顺序的规定。第一种方式，如第3章所述那样，使用互斥量来确定访问的顺序；当同一互斥量在两个线程同时访问前被锁住，那么在同一时间内就只有一个线程能够访问到对应的内存位置，所以后一个访问必须在前一个访问之后。另一种方式是使用原子操作(*atmic operations*)同步机制(详见5.2节中对于原子操作的定义)，去决定两个线程的访问顺序。使用原子操作来规定顺序在5.3节中会有介绍。当多余两个线程访问同一个内存地址时，对每个访问这都需要定义一个顺序。

如果不去规定两个不同线程对同一内存地址访问的顺序，那么访问都不是原子的；并且，当两个线程都是作者的时候，就会产生数据竞争和未定义行为。

一下的声明由为重要：未定义的行为是C++中最阴暗的角落。根据语言的标准，一旦应用中有任何未定义的行为，就很难预料会发生什么事情；完整应用中的行为现在是未定义的，并且其可能做任何事情。我就知道一个未定义行为的特定实例，让某人的显示器起火的案例。虽然这种事情应该不会发生在你身上，但是数据竞争绝对是一个严重的错误，并且需要不惜一切代价避免它

另一个重点是：当程序中的对同一内存地址中的数据访问存在竞争，你可以使用原子操作来避免未定义行为。当然，这不会阻止竞争自身——原子操作并没有指定那个访问首先去访问——但是原子操作把程序拉回了定义行为的区域内。

在我们了解原子操作前，还有一个有关对象和内存地址的概念需要重点去了解：修改顺序。

###5.1.3 修改顺序

每一个在C++程序中的对象，都有(由程序中的所有线程对象)确定好的修改顺序(*modification order*)，在的初始化开始阶段确定。在大多数情况下，这个顺序不同于执行中的顺序，但是在给定的执行程序中，系统中的所有线程都需要遵守这顺序。如果对象不是一个原子类型(将在5.2节详述)，你有责任确保有足够的同步操作，来确定每个线程都遵守了变量的修改顺序。当不同线程在不同序列中访问同一个值时，你可能就会遇到数据竞争或未定义行为(详见5.1.2节)。如果你使用原子操作，编译器就有责任去替你确定必要的同步操作。

这一要求意味着：投机执行是不允许的，因为一旦线程按修改顺序访问一个特殊的输入，之后的读操作，必须由线程返回较新的值，并且之后的写操作必须发生在修改顺序之后。同样的，对象读取操作允许在同一线程上，要不返回一个已写入的值，要不在对象的修改顺序后(也就是在读取后)写入另一个值。虽然，所有线程都需要遵守程序中每个独立对象的修改顺序，但是它们没有必要遵守在独立对象上的相对操作顺序。在5.3.3节中会有更多关于不同线程间操作顺序的内容。

所以，什么是原子操作？如何让它来规定顺序？接下来的一节中，会为你揭晓答案。

##5.2 C++中的原子操作和原子类型

###5.2.1 标准原子类型

###5.2.2 std::atomic_flag的相关操作

###5.2.3 std::atomic<bool>的相关操作

###5.2.4 std::atomic<T*>:指针运算

###5.2.5 标准的原子整型的相关操作

###5.2.6 std::atomic<>主要类的模板

###5.2.7 原子操作的释放函数