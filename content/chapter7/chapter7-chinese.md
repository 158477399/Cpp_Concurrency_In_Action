#第七章 无锁并发数据结构设计

**本章主要内容**

>实现无锁并发数据结构的设计<br>
>在无锁结构中内存管理技术<br>
>对无锁数据结构的简单指导<br>

在上一章中，我们了解了在设计并发数据结构时会遇到的问题，根据指导意见方向，确定我们的设计是安全的。我们会检查一些通用数据结构，并且看一下使用互斥锁对共享数据进行保护的实现例子。第一对例子就是使用一个互斥量来保护整个数据结构，不过后面的例子就使用了不止一个锁来保护数据结构不同的部分，并且允许对数据结构进行更高级别的并发访问。

互斥量是一个强大的工具，其可以保证在多线程情况下我们可以安全的访问数据结构，并且不会有条件竞争或破坏不变量的情况存在。对于使用互斥量的代码，其原因也是很简单的：就是让互斥量来保护数据。不过，这并不会如你所想的那样(*a bed of roses*)；你可以回看一下第3章，回顾一下错误的锁使用时如何造成死锁的，还可以看一下基于锁的队列和查询表的例子，看一下细粒度锁是如何潜在的影响真正的并发。如果你能写出一个无锁的并发安全的数据结构，那么就能避免这些潜在的问题。这样的数据结构叫做无锁(*lock-free*)数据结构。

在本章中，我们还会看到原子操作(第5章介绍)的“内存-顺序”特性，并使用这个特性来构建无锁数据结构。当你要设计这样的数据结构时，要格外的小心，因为这样的数据机构不是那么容易正确实现的，并且让其失败的条件很难复现。我们将从无锁数据的定义开始；而后，我们将继续通过几个例子来了解使用无锁数据结构的意义，而后给出一些通用的指导意见。

##7.1 定义和意义

，会使用互斥量，条件变量，以及“期望”来同步“阻塞”(*blocking*)数据的算法和数据结构。应用调用库函数，将会挂起一个执行线程，知道其他线程执行完某个特定的动作。库将调用阻塞操作来对线程进行阻塞，直到阻塞移除，线程才能继续处理自己的任务。通常，操作系统会完全挂起一个阻塞线程(并将其时间片交给其他线程)，直到其被其他线程“去阻”；“去阻”的方式很多，比如解锁一个互斥锁、提示一个条件变量达成或让一个“期望”就绪。

不使用阻塞库函数的数据结构和算法，被称为“无阻塞”(*nonblocking*)结构。“无阻塞”的数据结构并非都是无锁的(*lock-free*)，那么就让我们见识一下各种各样的“无阻塞”数据结构吧！

###7.1.1 非阻塞数据结构

回到第5章中，我们使用`std::atomic_flag`实现了一个简单的自旋锁。让我们再来看一下这段代码。

清单7.1 使用`std::atomic_flag`实现了一个简单的自旋锁
```c++
class spinlock_mutex
{
  std::atomic_flag flag;
public:
  spinlock_mutex():
    flag(ATOMIC_FLAG_INIT)
  {}
  void lock()
  {
    while(flag.test_and_set(std::memory_order_acquire));
  }
  void unlock()
  {
    flag.clear(std::memory_order_release);
  }
};
```

这段代码没有调用任何阻塞函数；lock()只是让循环持续调用test_and_set()，并返回false。这就是为什么取名为自旋锁的原因——代码“自旋”于循环当中。所以，这里没有阻塞调用，任意代码使用互斥量来保护共享数据都是非阻塞的。不过，这自旋锁不是无锁结构。这里还是用了一个锁，并且一次能锁住一个线程。让我们来看一下无锁结构的定义，这将有助于你判断哪些类型的数据结构是无锁的。

###7.1.2 无锁数据结构

将一个数据结构成为无锁结构，那么线程就可以并发的访问这个数据结构。线程不能做相同的操作；一个无锁队列可能允许一个线程进行压入数据，一个线程弹出数据，当有两个线程同时尝试添加元素时，这个数据结构将被破坏。不仅如此，当其中一个访问线程被调度器中途挂起时，其他线程必须能够继续完成他们自己的工作，不用等待挂起线程。

具有比较/交换操作的数据结构，通常比较/交换实现中都有一个循环。使用比较/交换操作的原因是，当有其他线程同时完成对对应数据的修改时，代码将恢复调用比较/交换操作前的数据。当其他线程被挂起时，且比较/交换操作执行成功，那么这样的代码就是无锁的。当执行失败时，你就需要一个自旋锁了，那么这个结构就是非阻塞且非无锁的结构。

无锁算法中的这中循环会让一些线程处于“饥饿”状态。如有线程在“错误”时间执行，那么第一个线程将会持续的尝试自己所要完成的操作 (其他程序继续执行)。无锁-无等待数据结构，就为了避免这种问题存在的。

###7.1.3 无等待数据结构

###7.1.4 无锁数据结构的利与弊