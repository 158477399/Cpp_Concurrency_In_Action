#第七章 无锁并发数据结构设计

**本章主要内容**

>实现无锁并发数据结构的设计<br>
>在无锁结构中内存管理技术<br>
>对无锁数据结构的简单指导<br>

在上一章中，我们了解了在设计并发数据结构时会遇到的问题，根据指导意见方向，确定我们的设计是安全的。我们会检查一些通用数据结构，并且看一下使用互斥锁对共享数据进行保护的实现例子。第一对例子就是使用一个互斥量来保护整个数据结构，不过后面的例子就使用了不止一个锁来保护数据结构不同的部分，并且允许对数据结构进行更高级别的并发访问。

互斥量是一个强大的工具，其可以保证在多线程情况下我们可以安全的访问数据结构，并且不会有条件竞争或破坏不变量的情况存在。对于使用互斥量的代码，其原因也是很简单的：就是让互斥量来保护数据。不过，这并不会如你所想的那样(*a bed of roses*)；你可以回看一下第3章，回顾一下错误的锁使用时如何造成死锁的，还可以看一下基于锁的队列和查询表的例子，看一下细粒度锁是如何潜在的影响真正的并发。如果你能写出一个无锁的并发安全的数据结构，那么就能避免这些潜在的问题。这样的数据结构叫做无锁(*lock-free*)数据结构。

在本章中，我们还会看到原子操作(第5章介绍)的“内存-顺序”特性，并使用这个特性来构建无锁数据结构。当你要设计这样的数据结构时，要格外的小心，因为这样的数据机构不是那么容易正确实现的，并且让其失败的条件很难复现。我们将从无锁数据的定义开始；而后，我们将继续通过几个例子来了解使用无锁数据结构的意义，而后给出一些通用的指导意见。

##7.1 定义和意义

###7.1.1 非阻塞数据结构

###7.1.2 无锁数据结构

###7.1.3 无等待数据结构

###7.1.4 无锁数据结构的利与弊