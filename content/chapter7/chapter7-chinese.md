#第七章 无锁并发数据结构设计

**本章主要内容**

>实现无锁并发数据结构的设计<br>
>在无锁结构中内存管理技术<br>
>对无锁数据结构的简单指导<br>

在上一章中，我们了解了在设计并发数据结构时会遇到的问题，根据指导意见方向，确定我们的设计是安全的。我们会检查一些通用数据结构，并且看一下使用互斥锁对共享数据进行保护的实现例子。第一对例子就是使用一个互斥量来保护整个数据结构，不过后面的例子就使用了不止一个锁来保护数据结构不同的部分，并且允许对数据结构进行更高级别的并发访问。

互斥量是一个强大的工具，其可以保证在多线程情况下我们可以安全的访问数据结构，并且不会有条件竞争或破坏不变量的情况存在。对于使用互斥量的代码，其原因也是很简单的：就是让互斥量来保护数据。不过，这并不会如你所想的那样(*a bed of roses*)；你可以回看一下第3章，回顾一下错误的锁使用时如何造成死锁的，还可以看一下基于锁的队列和查询表的例子，看一下细粒度锁是如何潜在的影响真正的并发。如果你能写出一个无锁的并发安全的数据结构，那么就能避免这些潜在的问题。这样的数据结构叫做无锁(*lock-free*)数据结构。

在本章中，我们还会看到原子操作(第5章介绍)的“内存-顺序”特性，并使用这个特性来构建无锁数据结构。当你要设计这样的数据结构时，要格外的小心，因为这样的数据机构不是那么容易正确实现的，并且让其失败的条件很难复现。我们将从无锁数据的定义开始；而后，我们将继续通过几个例子来了解使用无锁数据结构的意义，而后给出一些通用的指导意见。

##7.1 定义和意义

，会使用互斥量，条件变量，以及“期望”来同步“阻塞”(*blocking*)数据的算法和数据结构。应用调用库函数，将会挂起一个执行线程，知道其他线程执行完某个特定的动作。库将调用阻塞操作来对线程进行阻塞，直到阻塞移除，线程才能继续处理自己的任务。通常，操作系统会完全挂起一个阻塞线程(并将其时间片交给其他线程)，直到其被其他线程“去阻”；“去阻”的方式很多，比如解锁一个互斥锁、提示一个条件变量达成或让一个“期望”就绪。

不使用阻塞库函数的数据结构和算法，被称为“无阻塞”(*nonblocking*)结构。“无阻塞”的数据结构并非都是无锁的(*lock-free*)，那么就让我们见识一下各种各样的“无阻塞”数据结构吧！

###7.1.1 非阻塞数据结构

回到第5章中，我们使用`std::atomic_flag`实现了一个简单的自旋锁。让我们再来看一下这段代码。

清单7.1 使用`std::atomic_flag`实现了一个简单的自旋锁
```c++
class spinlock_mutex
{
  std::atomic_flag flag;
public:
  spinlock_mutex():
    flag(ATOMIC_FLAG_INIT)
  {}
  void lock()
  {
    while(flag.test_and_set(std::memory_order_acquire));
  }
  void unlock()
  {
    flag.clear(std::memory_order_release);
  }
};
```

这段代码没有调用任何阻塞函数；lock()只是让循环持续调用test_and_set()，并返回false。这就是为什么取名为自旋锁的原因——代码“自旋”于循环当中。所以，这里没有阻塞调用，任意代码使用互斥量来保护共享数据都是非阻塞的。不过，这自旋锁不是无锁结构。这里还是用了一个锁，并且一次能锁住一个线程。让我们来看一下无锁结构的定义，这将有助于你判断哪些类型的数据结构是无锁的。

###7.1.2 无锁数据结构

将一个数据结构成为无锁结构，那么线程就可以并发的访问这个数据结构。线程不能做相同的操作；一个无锁队列可能允许一个线程进行压入数据，一个线程弹出数据，当有两个线程同时尝试添加元素时，这个数据结构将被破坏。不仅如此，当其中一个访问线程被调度器中途挂起时，其他线程必须能够继续完成他们自己的工作，不用等待挂起线程。

具有比较/交换操作的数据结构，通常在比较/交换实现中都有一个循环。使用比较/交换操作的原因：当有其他线程同时对对应数据的修改时，代码将恢复调用比较/交换操作前的数据。当其他线程被挂起时，且比较/交换操作执行成功，那么这样的代码就是无锁的。当执行失败时，你就需要一个自旋锁了，那么这个结构就是非阻塞且非无锁的结构。

无锁算法中的这中循环会让一些线程处于“饥饿”状态。如有线程在“错误”时间执行，那么第一个线程将会持续的尝试自己所要完成的操作 (其他程序继续执行)。无锁-无等待数据结构，就为了避免这种问题存在的。

###7.1.3 无等待数据结构

无等待数据结构就是，无锁数据结构加上每个线程都能在有限的步数内完成他们所要完成的操作，且不管其他线程是如何工作的。这里，由于会和别的线程产生冲突，所以算法可以进行无数次尝试，因此并不是无等待的。

正确实现一个无锁的结构是十分困难的。因为，要保证每一个线程都能在有限步骤里完成操作，你需要保证每一个操作可以被一次性执行完成，且当一个线程执行这个操作时，不会让其他线程的操作失败。这会让算法中所使用到的操作变的相当复杂。

考虑到获取无锁或无等待的数据结构所有权是很困难的，那么你就需要一些理由来写一个数据结构；需要保证的是所得获益要大于实现成本。那么，就让我们来找一下实现成本和所得获益的平衡点吧！

###7.1.4 无锁数据结构的利与弊

我们使用无锁结构的主要原因是：其能够将并发最大化。使用基于锁的容器，都会让一个线程阻塞或等待第一个线程完成其工作；这里一个互斥锁削弱了结构的并发性。在无锁数据结构中，某些线程可以通过每一步的操作，递进的完成工作。在无等待数据结构中，每一个线程都可以转发进度，无论其他线程当时在做什么；其目的就是不需要等待。这种理想的方式实现起来很难。这种结构因为太简单，而不容易写出来，因为其本质上就是一个自旋锁。

使用无锁数据结构的第二个原因就是鲁棒性。当一个线程在获取一个锁时，被杀死，那么数据结构将被破坏。不过，当线程在无锁数据结构上执行操作，执行到一半死亡时，那么数据结构上的数据没有丢失(除了线程本身的数据)；其他线程依旧可以正常执行。

另一方面，当你不能排除访问数据结构的线程时，就需要小心的确认不变量的状态，或选择替代品来代替不变量保持状态。同时，你还需要关注附加在操作上的顺序约束。为了避免未定义行为，及相关的数据竞争，就必须使用原子操作对修改操作进行限制。不过，仅使用原子操作时不够的；你需要确定能被其他线程看到的修改，是尊顺一个正确的顺序。所有的一切说明，想要在写一个无锁-线程安全的数据结构是十分困难的。

因为，没有任何锁(有可能存在活锁(*live locks*))，死锁问题就不会困扰无锁数据结构。活锁的产生是因为，两个线程同时尝试修改数据结构，不过每个线程所做的修改操作都会让另一个线程重启，所以两个线程就会陷入循环，多次的尝试完成自己的操作。试想有两个人要过独木桥。当两个人从两头向中间走的时候，他们会在中间碰到，然后不得不再走回出发的地方，再次尝试过独木桥。这里，要打破僵局，除非有人先到独木桥的另一端(或因商量好了，或因走的块，或纯粹是运气)，要不这个循环将一直重复下去。不过活锁的存在时间并不长，因为其依赖于精确的线程调度。所以其只是对性能有所消耗，而不是一个长期的问题；不过，这个问题仍需要关注。根据定义，无等待的代码不会被活锁所困扰，因为其操作执行步骤是有上限的。换个角度，无等待的算法要比等待算法的复杂度高，且即使没有其他线程访问数据结构，也可能需要更多步骤来完成对应操作。

这就是无锁-无等待代码的缺点：虽然提高了并发访问的能力，减少了单个线程的等待时间，但是其可能会将整体性能拉低。首先，使用原子操作的无锁代码，要慢于无原子操作的代码，原子操作就相当于无锁数据结构中的锁。不仅如此，硬件必须通过同一个原子变量对线程间的数据进行同步。在第8章，你将看到与“乒乓”缓存相关的原子变量(多个线程访问同时访问)，将会成为一个明显的性能瓶颈。在提交代码之前，对性能相关的方面进行检查是很重要的(最坏的等待时间，平均等待时间，整体执行时间，或者其他指标)，无论是基于锁的数据结构，还是无锁的数据结构。

先来看几个例子。

##7.2 无锁数据结构的例子

为了演示一些在设计无锁数据结构中所使用到的技术，我们将看到一些无锁实现的简单数据结构。这里不仅要在每个例子中描述一个有用的数据结构实现，还将使用这些例子的某些特别的点来阐述对于无锁数据结构的设计。

如之前所提到的，无锁结构体依赖与原子操作和内存顺序相关的保证，来确保数据结构能被多线程以正确的顺序访问。最初，我们对所有原子操作使用默认的memory_order_seq_cst内存序，因为简单，所以使用(所有memory_order_seq_cst都遵循一种顺序)。不过，在后面的例子中，我们将会降低内存序的要求，使用memory_order_acquire, memory_order_release, 甚至memory_order_relaxed。虽然这个例子中没有直接的使用锁，但需要注意的是`std::atomic_flag`能保证实现中无锁的使用。一些平台中的无锁结构实现，实际上在C++的标准库的实现中，使用了内部锁(详见第5章)。在另一些平台上，基于锁的简单数据结构可能会更适合，不过还有很多平台不能一一说明；在选择一种实现前，你需要明确你的需求，并且配置各种选项以满足要求。

那么，回到数据结构上来吧，最简单的数据结构——栈。

###7.2.1 写一个无锁的线程安全栈

栈的要求很简单：查询节点的顺序是添加顺序的逆序——先入后出(LIFO)。所以，要确保一个值安全的添加入栈就十分重要，因为其可能马上被其他线程索引到，并且确保只有一个线程能索引到给定值也是很重要的。最简单的栈就是链表；head指针指向第一个节点(可能是下一个被索引到的节点)，并且每个节点依次指向下一个节点。

在这样的情况下，添加一个节点相对来说很简单：

1. 创建一个新节点。
2. 将当新节点的next指针指向当前的head节点。
3. 让head节点指向新节点。

在只有单线程的上下文中，这种方式没有问题，不过当多线程对栈进行修改时，这几步就不够用了。至关重要的是，当有两个线程同时添加节点的时候，在第二步和第三步的时候会产生条件竞争：一个线程可能在修改head的值时，另一个线程正在执行第2步，并且在第3步中对head进行更新。这就会使之前那个线程的工作被丢弃，亦或是造成更加糟糕后果。在我们了解如何解决这个条件竞争之前，还要注意一个很重要的事：当head被更新，并指向了新节点，另一个线程就能读取到这个节点了。因此，在head设置为指向新节点前，让新节点完全准备就绪就变得很重要了；因为，在这之后你就不能对节点进行修改了。

OK，那如何应对讨厌的条件竞争呢？答案就是：在第3步的时候使用一个原子“比较/交换”操作，来保证当步骤2对head进行读取的时候，不会对head进行修改。当有修改时，你可以循环做“比较/交换”操作。下面的代码就展示了不用锁来实现线程安全的push()函数。

清单7.2 不用锁实现push()
```c++
template<typename T>
class lock_free_stack
{
private:
  struct node
  {
    T data;
    node* next;

    node(T const& data_):  // 1
     data(data_)
    {}
  };

  std::atomic<node*> head;
public:
  void push(T const& data)
  {
    node* const new_node=new node(data); // 2
    new_node->next=head.load();  // 3
    while(!head.compare_exchange_weak(new_node->next,new_node));  // 4
  }
};
```

上面代码近乎能匹配之前所说的三个步骤：创建一个新节点②，设置新节点的next指针指向当前head③，并且设置head指针指向新节点④。node结构用其自身的构造函数来进行数据填充①，必须保证节点在构造完成后随时能被弹出。而后需要使用compare_exchange_weak()来保证在被存储到new_node->next的head指针和之前的一样③。代码的亮点是使用比较/交换操作：当其返回false时，以为这比较失败(例如，head被其他线程锁修改)，new_node->next作为操作的第一个参数，将会更新head的当前值。循环中不需要每次都重新加载head指针，因为编译器会帮你完成这件事。同样的，因为循环可能直接就失败了，所以这里使用compare_exchange_weak要好于使用compare_exchange_strong(详见第5章)。

所以，这里可能就不需要pop()操作了，可以快速检查一下push()的实现是否有违背指导意见。这里唯一一个能抛出异常的地方就是在构造新node的时候①，但其会自行处理，并且链表中的内容没有被修改，所以这里是很安全的。因为在构建数据的时候，是将其作为node的一部分作为存储，并且使用compare_exchange_weak()来更新head指针，这里也没有恶性的条件竞争。在比较/交换成功时，节点已经准备就绪，且随时可以提取。因为这里没有锁，所以就不存在死锁的情况，这里的push()函数实现的很成功。

那么，你现在已经有往栈中添加数据的方法了，现在需要删除数据的方法。其步骤如下，也很简单：

1. 读取当前head指针的值。
2. 读取head->next。
3. 设置head到head->next。
4. 通过索引node，返回data数据。
5. 删除索引节点。

不过在多线程环境下，就不像看起来那么简单了。当有两个线程要从栈中移除数据，两个线程可能在步骤1中读取到同一个head(值相同)。当其中一个线程处理到步骤5，而另一个线程还在处理步骤2时，这个还在处理步骤2的线程将会解引用一个悬空指针。这只是写无锁代码所遇到的最大问题之一，所以现在只能跳过步骤5，让节点泄露。

这样也不会解决所有问题。另一个问题：当两个线程读取到head的值是同一个，他们将返回同一个节点。这就违反了栈结构的意图，所以你需要避免这样的问题。你可以像在push()函数中解决条件竞争那样来解决这个问题：使用比较/交换操作更新head。当比较/交换操作失败时，不是一个新节点已被推入，就是其他线程已经弹出了你想要弹出的节点。无论是那种情况，你都得返回步骤1(比较/交换操作将会重新读取head)。

当比较/交换调用成功，你就可以知道你的线程是弹出给定节点的唯一线程，那么你就可以放心的执行步骤4了。这里先看一下pop()的雏形：

```c++
template<typename T>
class lock_free_stack
{
public:
  void pop(T& result)
  {
    node* old_head=head.load();
    while(!head.compare_exchange_weak(old_head,old_head->next));
    result=old_head->data;
  }
};
```

虽然这段代码很优雅，但是这里还有两个有关节点泄露的问题。首先，这段代码在空链表的时候不工作：当head指针式一个空指针时，当要访问next指针时，其将引起未定义行为。这很容易通过对nullptr的检查进行修复(在while循环中)，要不对空栈抛出一个异常，要不返回一个bool值来表明成功与否。

###7.2.2 停止内存泄露：使用无锁数据结构管理内存

###7.2.3 检测使用危险指针(不可回收)的节点

**对危险指针(较好)的回收策略**

###7.2.4 检测使用引用计数的节点

###7.2.5 应用于无锁栈上的内存模型

###7.2.6 写一个无锁的线程安全队列

**push()中多线程的处理**

**让无锁队列帮助更多的线程**

##7.3 对于设计无锁数据结构的指导建议

###7.3.1 指导建议：使用`std::memory_order_seq_cst`的原型

###7.3.2 指导建议：对无锁内存的回收策略

###7.3.3 指导建议：小心[ABA问题](https://en.wikipedia.org/wiki/ABA_problem)

###7.3.4 指导建议：识别忙等待循环和帮助其他线程

##7.4 小结