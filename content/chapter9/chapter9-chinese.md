#第章 高级线程管理

**本章主要内容**

- 线程池<br>
- 处理线程池中任务的依赖关系<br>
- 池中线程如何获取任务<br>
- 中断线程<br>

在之前的章节中，我们通过创建`std::thread`对象来对每一个线程进行管理。在一些地方，你已经看到这种方式是不可取的了，因为需要在线程的整个生命周期中对其进行管理，根据当前使用的硬件来决定恰当的线程数量，等等。理想情况是将代码划分为最小块，以便能并发执行，然后将他们传递给处理器和标准库，进行性能的并行优化。

另一种情况是，当你使用多线程来解决某个问题时，当某个条件达成的时候，就可以提前结束。这可能是因为结果已经确定好了，或者因为发生了错误，亦或者是用户显式的终止操作。无论是哪种原因，线程都需要发送“请停止”的请求，放弃给定的任务，清理，然后尽快停止运行。

在本章，我们将了解一下管理线程和任务的机制，从自动管理线程数量和自自动管理划分任务开始。

##9.1 线程池

在很多公司里面，雇员通常会在办公室度过他们的办公时光(偶尔也会外出访问客户或供应商)，或是参加贸易展会。虽然这些路程可能很有必要，并且可能需要很多人一起去，不过对于一些比较特别的雇员来说，这一去就是几个月，甚至是几年。公司要给每个雇员都配一辆车，这基本上是不可能的，不过公司可以提供一些共用车辆；这样就会有一定数量车，来让所有雇员使用。当一个员工要去异地旅游时，那么他就可以从共用车辆中预定一辆，并在返回公司的时候将车交还。如果有一天共用车辆没有闲置的，雇员就不得不将其旅程后延了。

线程池就是类似的一种方式。在大多数系统中，将每个任务制定给一个线程是不切实际的，不过可以利用现有的并发可能，进行并发。线程池就提供了这样的功能；提交到线程池中的任务将会被并发执行，提交的任务将会挂在任务队列上。队列中的每一个任务都会被池中的一个工作线程所获取，当任务执行完成后，再回到线程池中获取下一个任务。

创建一个线程池的时候，会遇到几个关键的设计问题，比如，可使用的线程数量，高效的任务分配方式，以及是否需要等待一个任务完成。在本节，我们将看到很多线程池的实现是如何解决这些问题的，让我们从最简单的线程池开始吧！

###9.1.1 最简单的线程池

###9.1.2 等待任务提交到线程池中

###9.1.3 需要等待的任务

###9.1.4 避免任务队列的竞争

###9.1.5 获取任务

##9.2 中断线程

###9.2.1 启动和中断其他线程

###9.2.2 检查线程是否中断

###9.2.3 中断条件变量等待

###9.2.4 中断`std::condition_variable_any`的等待

###9.2.5 中断其他阻塞调用

###9.2.6 处理中断

###9.2.7 应用退出时中断后台任务

##9.3 小结