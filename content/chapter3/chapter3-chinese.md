#第三章 线程间共享数据

**本章主要内容**

>共享数据带来的问题<br>
>使用互斥量保护数据<br>
>数据保护的替代方案<br>

使用线程并发的一个好处是可以直接共享数据，我们在本章开始前，已经对线程管理有所了解了，现在让我们来看一下“共享数据的那些事”。

想象一下，当你和你的一个朋友合租在一个公寓中。公寓只有一个厨房和一个卫生间。当你要使用卫生间的时候，你的朋友一直在占用卫生间，那么你就会不能使用了（除非你们特别友好，好到可以在同一时间使用一个房间）。同样的问题也会出现在厨房，当有一个组合式烤箱，在烤香肠的时候，也在做一个蛋糕，那么我们可能得不到我们想要的食物（会得到不想要的香肠味的蛋糕）。此外，当我们在公共空间将一件事做到一半时，发现某些需要的东西被别人接走了，或者，当我们离开的一小段时间内有些东西被改动了，这都会令我们沮丧。

同样的问题，也困扰着线程。当你想要在线程见共享数据的时候，你必须定一些规矩用来限定线程可访问的数据位，还有，当一个线程更新了共享数据，需要对其他线程进行告知。从易用性上来说，在同一进程中的多个线程进行数据共享，既有利，又有弊。错误的共享数据使用是导致并发先关bug产生的一个主要原因，并且后果要比香肠味的蛋糕更加严重。

本章就在C++中，进行安全的数据共享为主题。避免上述及其他潜在问题的发生，并将共享数据的优势发挥到最大。

##3.1 共享数据带来的问题

当问题涉及到共享数据时，则该问题很可能是共享数据被修改所导致。如果所有共享数据都是只读的，那么没问题，因为只读操作不会影响到数据，更不会对数据进行修改，所以所有线程获取到的都是同样的数据。但是，当一个或多个线程要修改共享数据时，就会产生很多潜在的麻烦。在这种情况下，你就必须小心并谨慎的确保一切都工作正常。

不变量（*invariants*）的概念已经广泛使用，并且对程序员们编写的程序产生帮助——关于特殊结构体的描述，比如，“此变量包含列表中的项数”。这些不变量通常会在一次更新中被破坏，特别是哪些比较复杂的数据结构，或者一次更新就要改动很多值。

一个双链表，每一个节点都有一个指针指向列表中下一个节点，还有另外一个指针指向前一个节点。其中不变量就是节点A中指向“下一个”节点B的指针，还有前向指针。为了从列表中删除一个节点，其两边的节点的指针都需要更新。当其中一边更新完成时，不变量就被破坏了，直到另一边也完成更新；
在两边都完成更新后，不变量就又稳定了。

从一个列表中删除一个节点的步骤如下（如图3.1）<br>
1. 找到要删除的节点N<br>
2. 更新前一个节点指向N的指针，让这个指针指向N的下一个节点<br>
3. 更新后一个节点指向N的指针，让这个指正指向N的前一个节点<br>
4. 删除节点N<br>

![](https://raw.githubusercontent.com/xiaoweiChen/Cpp_Concurrency_In_Action/master/images/chapter3/3-1.png)

图3.1 从一个双链表中删除一个节点

如你所见，在图中的b和c中，在相同的方向上指向和原来已经不一致了，这就破坏不变量。

在线程间最简单的潜在问题就是修改共享数据，致使不变量遭到破坏。当你不做些事来确保在这个过程中不会有其他线程进行访问的话，可能就有线程访问到刚刚删除一边的节点，这样的话，线程就读取到要删除的那个节点的数据（因为只有一边的连接被修改，如图3.1中的b一般），所以，这里说不变量被破坏。破坏不变量的后果可能多种多样；当其他线程按从左往右的书序来访问列表，那么它将跳过那个被删除的节点。在另一方面，如有第二个线程尝试删除图中右边的节点，那么它可能会让数据结构产生永久性的损坏，并使程序崩溃。无论结果如何，这都是并行代码常见错误产生的原因：条件竞争（*race condition*）。

###3.1.1 条件竞争

假设你去电影院买电影票。如果这是一家很大的电影院，有很多收银员，那么很多人可以在同一时间进行电影票的选购。当另一个收银台也在卖你想看的这场电影的电影票，那么你的座位选择范围就取决于在之前已预定的座位。当只有少量的座位剩下，这就意味着：这可能是一场抢票比赛，看谁能抢到最后一张票。这就是一个条件竞争的例子：你的座位（或者你的电影票）都取决于两种购买方式的相对顺序。

在并发中，竞争条件的形成，取决于两个或更多线程的相对执行顺序。

















