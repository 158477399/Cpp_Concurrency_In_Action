#第三章 线程间共享数据

**本章主要内容**

>共享数据带来的问题<br>
>使用互斥量保护数据<br>
>数据保护的替代方案<br>

使用线程并发的一个好处是可以直接共享数据，我们在本章开始前，已经对线程管理有所了解了，现在让我们来看一下“共享数据的那些事”。

想象一下，当你和你的一个朋友合租在一个公寓中。公寓只有一个厨房和一个卫生间。当你要使用卫生间的时候，你的朋友一直在占用卫生间，那么你就会不能使用了（除非你们特别友好，好到可以在同一时间使用一个房间）。同样的问题也会出现在厨房，当有一个组合式烤箱，在烤香肠的时候，也在做一个蛋糕，那么我们可能得不到我们想要的食物（会得到不想要的香肠味的蛋糕）。此外，当我们在公共空间将一件事做到一半时，发现某些需要的东西被别人接走了，或者，当我们离开的一小段时间内有些东西被改动了，这都会令我们沮丧。

同样的问题，也困扰着线程。当你想要在线程见共享数据的时候，你必须定一些规矩用来限定线程可访问的数据位，还有，当一个线程更新了共享数据，需要对其他线程进行告知。从易用性上来说，在同一进程中的多个线程进行数据共享，既有利，又有弊。错误的共享数据使用是导致并发先关bug产生的一个主要原因，并且后果要比香肠味的蛋糕更加严重。

本章就在C++中，进行安全的数据共享为主题。避免上述及其他潜在问题的发生，并将共享数据的优势发挥到最大。

##3.1 共享数据带来的问题

当问题涉及到共享数据时，则该问题很可能是共享数据被修改所导致。如果所有共享数据都是只读的，那么没问题，因为只读操作不会影响到数据，更不会对数据进行修改，所以所有线程获取到的都是同样的数据。但是，当一个或多个线程要修改共享数据时，就会产生很多潜在的麻烦。在这种情况下，你就必须小心并谨慎的确保一切都工作正常。

不变量（*invariants*）的概念已经广泛使用，并且对程序员们编写的程序产生帮助——关于特殊结构体的描述，比如，“此变量包含列表中的项数”。这些不变量通常会在一次更新中被破坏，特别是哪些比较复杂的数据结构，或者一次更新就要改动很多值。

一个双链表，每一个节点都有一个指针指向列表中下一个节点，还有另外一个指针指向前一个节点。其中不变量就是节点A中指向“下一个”节点B的指针，还有前向指针。为了从列表中删除一个节点，其两边的节点的指针都需要更新。当其中一边更新完成时，不变量就被破坏了，直到另一边也完成更新；
在两边都完成更新后，不变量就又稳定了。

从一个列表中删除一个节点的步骤如下（如图3.1）<br>
1. 找到要删除的节点N<br>
2. 更新前一个节点指向N的指针，让这个指针指向N的下一个节点<br>
3. 更新后一个节点指向N的指针，让这个指正指向N的前一个节点<br>
4. 删除节点N<br>

![](https://raw.githubusercontent.com/xiaoweiChen/Cpp_Concurrency_In_Action/master/images/chapter3/3-1.png)

图3.1 从一个双链表中删除一个节点

如你所见，在图中的b和c中，在相同的方向上指向和原来已经不一致了，这就破坏不变量。

在线程间最简单的潜在问题就是修改共享数据，致使不变量遭到破坏。当你不做些事来确保在这个过程中不会有其他线程进行访问的话，可能就有线程访问到刚刚删除一边的节点，这样的话，线程就读取到要删除的那个节点的数据（因为只有一边的连接被修改，如图3.1中的b一般），所以，这里说不变量被破坏。破坏不变量的后果可能多种多样；当其他线程按从左往右的书序来访问列表，那么它将跳过那个被删除的节点。在另一方面，如有第二个线程尝试删除图中右边的节点，那么它可能会让数据结构产生永久性的损坏，并使程序崩溃。无论结果如何，这都是并行代码常见错误产生的原因：条件竞争（*race condition*）。

###3.1.1 条件竞争

假设你去电影院买电影票。如果这是一家很大的电影院，有很多收银员，那么很多人可以在同一时间进行电影票的选购。当另一个收银台也在卖你想看的这场电影的电影票，那么你的座位选择范围就取决于在之前已预定的座位。当只有少量的座位剩下，这就意味着：这可能是一场抢票比赛，看谁能抢到最后一张票。这就是一个条件竞争的例子：你的座位（或者你的电影票）都取决于两种购买方式的相对顺序。

在并发中，竞争条件的形成，取决于一个以上线程的相对执行顺序；每个线程都抢着完成自己的任务。大多数情况下，即便它们会改变执行顺序，这种竞争也是良性的，其结果也是可以接受的。例如，如果两个线程同时向一个处理队列中添加任务，谁先谁后就没有什么影响，系统提供的不变量保持不变。当不变量遭到破坏时，才会导致条件竞争，例如双向链表的那个例子。在并发中，条件竞争这个数据通常用于表示“有问题的”（*problematic*）条件竞争；我们对良性的，且不产生问题的条件竞争不感兴趣。在C++标准中，也定义了数据竞争（*data race*）这个术语，因为再并发中去修改一个独立对象（参考5.1.2节），所以这是一种特殊的条件竞争；数据竞争是（可怕的）未定义行为（*undefine behavior*）的起因。

有问题的条件竞争通常发生在，完成对多于一个的数据块的修改时，例如，对两个连接指针的修改（在图3.1中）。因为操作要访问两个独立的数据块，数据块将会被独立的指令所修改，并且另一个线程可能在只完成一半的时，就对数据块进行访问。条件竞争很难找，并且很难复现，因为概率太低。当如CPU指令那样的连续修改完成后，这个问题能再次复现出的几率就相当低了，即使这个数据结构可以让其他并发线程访问。当系统负载增加时，随着执行数量增加，执行序列的问题复现的概率也在增加。这几乎是不可避免的，这样的问题会出现在负载比较大的情况下。条件竞争通常是时间敏感的，所以，当运行在调试模式时，它们常会完全消失；因为，调试模式会影响程序的执行时间，即使影响不多。

当你以写多线程程序为生，条件竞争就会成为你生命中不快乐的源泉；在编写软件时，会使用大量复杂的操作，用来避免恶性条件竞争。

###3.1.2 避免恶性条件竞争

这里有很多方法来解决恶性条件竞争。最简单的办法是对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态。从其他访问线程的角度来看，改变要不就是已经完成了，要不就还没开始。C++标准库提供很多类似的机制，我们会在本章进行介绍。

另一个选择是改动数据结构和不变量的设计，修改完的结构需能完成一系列不可分割的变化，也就是保证每个不变量保持不变的状态。这就是无锁编程（*lock-free programming*）的方式，不过，这种方式很难得到正确的结果。如果你做到这个级别上了，无论是内存模型存在细微的差异，还是，线程有潜能看到这组值，都会让工作变的复杂。内存模型的问题将在第5章讨论，无锁编程将在第7章讨论。

另一种处理条件竞争的方式是，使用事务（*transacting*）的方式去处理数据结构的更新，这里的处理就如同数据库进行更新一样。所需的一些修改数据和读取都存储在一个事务日志中，然后将之前的操作合为一步，再进行提交。当数据结构已经被另一个线程修改后，或处理已经重启的情况下，提交会无法处理。这称作为“软件事务内存”（*software transactional memory ( STM )*），在理论研究中，这是一个很活跃研究领域。这个概念将不会在本书中再进行介绍，因为在C++中没有对STM进行直接支持。但是，基本思想我们会在后面提及。

保护共享数据结构的最基本的方式，是使用C++标准库提供的互斥量（*mutex*），我先来看一下这个。

##3.2 使用互斥量保护共享数据

当你的程序中有共享数据，你肯定不想让其陷入条件竞争，或是不变量被破坏。如果你将所有代码可访问的数据标为互相排斥（*mutually exclusive*），就很不优雅；这样的话，当其中任一线程运行访问数据时，其他线程想要访问数据，就必须等待第一个线程结束吗？这样很有可能会让一个线程看到已破坏的不变量，也就是第一个线程正在做修改的时候。

当访问共享数据前，使用互斥量将相关数据锁住，并且当访问结束后，将数据解锁。线程库需要保证，当一个线程使用一个特定互斥量锁住共享数据，其他所有的线程想要访问被锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能再进行访问。这就保证了所有线程只能看到自治区域内的共享数据，并避免不变量破坏。

互斥量是C++中用来保护数据的一种常用手段，但是互斥量不是“银弹”；它可以用来保护正确的数据（见3.2.2节），也可以避免接口中存在着的条件竞争（见3.2.3节）。互斥量自身也有问题，造成死锁（见3.2.4节），对数据保护的太多（或太少）（见3.2.8节）。

让我们从最基本的开始吧。

###3.2.1 在C++中使用互斥量

在C++中，你可以使用`srd::mutex`来创建一个互斥量实例，通过调用成员函数`lock()`进行上锁；同样的，也可以调用成员函数`unlock()`进行解锁。不过，这里不推荐实践中直接去调用成员函数，因为调用成员函数就以为着，你必须记着在每个函数出口都要去调用`unlock()`，也包括异常的情况。C++标准库提供了一个`std::lack_guard`类模板，实现了是RAII风格的互斥量；其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，这就保证了一个已锁的互斥量可以被正确的解锁。在下面的程序清单中，展示了如何在多线程程序中，使用`std::mutex`构造的`std::lock_guard`实例，对一个列表进行访问保护。`std::mutex`和`std::lock_guard`都在<mutex>头文件中声明。

列表3.1 使用互斥量保护列表
```c++
#include <list>
#include <mutex>
#include <algorithm>

std::list<int> some_list;    // 1
std::mutex some_mutex;    // 2

void add_to_list(int new_value)
{
  std::lock_guard<std::mutex> guard(some_mutex);    // 3
  some_list.push_back(new_value);
}
bool list_contains(int value_to_find)
{
  std::lock_guard<std::mutex> guard(some_mutex);    // 4
  return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();
}
```

在清单3.1中，这里有一个全局变量 ①，这个全局变量又一个全局的互斥量来保护 ②。在**add_to_list()** ③ 和**list_contains()** ④ 函数中使用`std:;lock_guard<std::mutex>`，使得在这两个函数中对数据的访问是互斥的：**list_contains()**不可能看到被**add_to_list()**修改到一半的列表。

在某些情况下，这个全局变量使用的是没问题的；不过，在大多数情况下，需要保护的数据通常会与互斥量放在同一个类中，而不是定义成全局变量。这是一个标准的面向对象设计准则：将其放在一个类中，就可让他们联系在一起，也可对类的功能进行封装，并进行数据保护。在这种情况下，函数**add_to_list**和**list_contains**可以作为这个类的成员函数，并且互斥量和要保护的数据，在类中都需要定义为private成员，这就会让访问数据的代码变的清晰，并且容易看出在什么时候对互斥量进行上锁。当所有成员函数都会在调用时对数据上锁，在结束的时候对数据解锁，那么这就为所有的访问保证了数据的不变量不被破坏。

当然，也不是什么时候都这么理想，聪明的你一定早就注意到了：当其中一个成员函数返回的是保护数据的指针或引用时，即使成员函数都很好的对数据进行了保护，但是你破坏了他们的保护。具有访问能力的指针或引用可以访问（并可能修改）被保护的数据，而不会被互斥锁限制。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门。

###3.2.2 保护共享数据的结构

如你之前所见，单使用互斥量保护数据是很困难的，需要配合`std::lock_guard`对象在每个成员函数中，才能做到正真的保护；一个迷失的指针或引用，将会让这种保护形同虚设。在这个层面上，检查迷失指针或引用是很容易的；只要让成员函数不返回指针或引用，通过函数的返回值或一个输出参数，来保证数据的安全性。如果你想更深入的讨论，那就不会这么简单了——或者说没有什么是简单的。在确保成员函数不会传出指针或引用的同时，检查不通过指针或引用的方式来调用成员函数也是很重要的（当这个操作不在你的控制下）。这是很危险的：这些函数可能在互斥量没有保护到的地方，存储着指针或者引用。特别危险的是：将保护数据作为一个运行时参数，如同下面清单中所示那样。

清单3.2 无意中传递了保护数据的引用
```c++
class some_data
{
  int a;
  std::string b;
public:
  void do_something();
};

class data_wrapper
{
private:
  some_data data;
  std::mutex m;
public:
  template<typename Function>
  void process_data(Function func)
  {
    std::lock_guard<std::mutex> l(m);
    func(data);    // 1 传递“保护”数据给用户函数
  }
};

some_data* unprotected;

void malicious_function(some_data& protected_data)
{
  unprotected=&protected_data;
}

data_wrapper x;
void foo()
{
  x.process_data(malicious_function);    // 2 传递一个恶意函数
  unprotected->do_something();    // 3 在无保护的情况下访问保护数据
}
```

在这个例子中，**process_data**看起来是十分害的。虽然`std::lack_guard`能够很好的保护数据，但当调用了用户提供的函数**func** ① ，就会让**foo**传递**malicious_function**函数指针，这个函数指针就可以用来传出保护数据 ②；在之后的**do_something()**调用时，就可以直接使用保护数据，并完全避开了互斥锁。

幸运的是，这段问题代码还没有做什么出格的事情：因为代码已标记所有可访问的数据结构是互斥的。但不幸的是，这种情况下，C++线程库无法提供帮助；它只能在程序中，用正确的互斥锁去保护你的数据。从乐观的角度上看，在这种情况下，你是有方法可循的：切勿在互斥锁范围外传递保护数据的指针或引用，无论是函数返回值，还是存储在外部可见内存，亦或是将他们已参数的形式传递到用户提供的函数中去。

这在问题在使用互斥量保护共享数据时经常发生，从长远角度来看，这就会形成一个潜在的陷阱。

在下一节中，你将会看到，即便是使用了互斥量对数据进行了保护，但是条件竞争依旧会存在。

###3.2.3 接口中的条件竞争

只因为你使用了互斥量或其他机制保护了共享数据，你就不必再为条件竞争所担忧；你依旧需要对保护所做的保护措施进行确定。可以参照一下双向列表那个例子。当节点正在删除，或节点正在修改时，为了让一个线程安全的删除一个节点，你需要防止对这三个节点的并发访问。如果你只对指向每个节点的指针进行访问保护，那就和没有使用互斥量一样，因为条件竞争仍会发生——每步中的指针是不需要保护的，但是整个数据结构和整个删除操作，是需要保护的。这里，最简单的解决方案就是使用一个互斥量来保护整个链表，如同清单3.1所做。

尽管每个对链表的独立操作是安全的，但不意味着你就能走出困境；在一个很简单的接口中，你依旧可能遇到条件竞争。在一个`std::stack`的栈结构数据容器（清单3.3）。除了构造和`swap()`（互换）以外，你只能对`std::stack`做五件事：`push()`一个新元素进栈，`pop()`一个元素出栈，`top()`查看栈顶元素，`empty()`判断栈是否是空栈，`size()`了解栈中有多少个元素。当你修改`top()`，使其返回一个拷贝，而非一个引用，并且对内部数据使用一个互斥量进行保护，那么这个接口就会有条件竞争的存在。这不仅仅是基于互斥量实现的问题；在一个无锁实现的接口中，条件竞争依旧会产生。

清单3.3 `std::stack`容器的实现
```c++
template<typename T,typename Container=std::deque<T> >
class stack
{
public:
  explicit stack(const Container&);
  explicit stack(Container&& = Container());
  template <class Alloc> explicit stack(const Alloc&);
  template <class Alloc> stack(const Container&, const Alloc&);
  template <class Alloc> stack(Container&&, const Alloc&);
  template <class Alloc> stack(stack&&, const Alloc&);
  
  bool empty() const;
  size_t size() const;
  T& top();
  T const& top() const;
  void push(T const&);
  void push(T&&);
  void pop();
  void swap(stack&&);
};
```

`empty()`和`size()`的实现有问题，其结果是不能信赖。虽然在调用并返回时可能是正确的，但其他线程也是可以随意的访问栈的，并且可能`push()`多个新元素到栈中，也可能`pop()`出一些已在栈中的元素。这样的话，之前从`empty()`和`size()`得到的结果就有问题了。

特别是，当栈实现是非共享的，使用`empty()`检查完栈，当栈非空时，再调用`top()`访问栈顶部的元素。如下代码所示：

```c++
stack<int> s;
if (! s.empty()){    // 1
  int const value = s.top();    // 2
  s.pop();    // 3
  do_something(value);
}
```

以上是单线程安全代码：对一个空栈使用`top()`，是未定义行为，会产生各种奇怪的结果。对与一个共享的栈对象，这样的调用顺序就未必安全了，因为可能会发生在其他线程调用`pop()`对栈中的元素进行删除时，另一个线程正在调用`empty()` ①，并在判断非空后调用` top()`②。这是一个经典的条件竞争，使用互斥量对内部数据进行保护，但依旧不会阻止条件竞争的发生。

这个问题有解吗？有！

这个问题发生在接口设计上，所以解决的方法也就是改变接口实现。有人会问：怎么改？在这个简单的例子中，当调用`top()`时，发现栈已经是空的了，那么就抛出异常。虽然这能直接解决这个问题，但这是一个笨拙的解决方案，这样的话，即使`empty()`返回false的情况下，你都异常捕获机制。本质上，这样的改变会让`empty()`成为一个冗余函数。

当你仔细的观察过之前的代码段，你就会发现另一个潜在的条件竞争，就是在调用`top()` ② 和`pop()` ③ 之间。当两个线程运行在之前的代码中，并且都引用同一个栈对象。这就不是寻常的情况了；当为了性能使用线程，多个线程在使用不同的数据执行相同的操作，这是很平常的；并且，一个共享栈对象是理想的分工工具。假设，初始栈中只有两个元素，这时`empty()`和`top()`不会有竞争，同时考虑一下潜在的运行模式。

当栈被一个内部互斥量所保护时，在任一时间内，只有一个线程可以调用栈的成员函数，所以调用可以很好交错运行，并且do_something()是可以并发运行的。在表3.1中，会展示一种可能的执行顺序。

表3.1 一种可能执行顺序

| Thread A | Thread B |
| ------------ |--------------|
|if (!s.empty);||
||if(!s.empty);|
|int const value = s.top();||
||int const value = s.top();|
|s.pop();||
|do_something(value);|s.pop();|
||do_something(value);|

如你所见，当线程运行时，在`top()`的两次调用中，栈没被修改，所以每个线程能得到同样的值。不仅是这样，在调用`pop()`函数调用的过程中（两次），`pop()`函数没有被调用。这样，在其中一个值再读取的时候，虽然不会出现“写后读”的情况了，但其值被处理了两次。这是另一种条件竞争，比未定义`empty()/top()`的竞争更加严重；虽然其结果依赖于`do_something()`的结果，但是，因为看起来没有任何错误，就会让这个漏洞变的很难找。

这就需要接口设计上需要更大的改动，提议之一就是使用同一互斥量来保护`top()`和`pop()`。Tom Cargill[1] 指出当一个对象的拷贝构造函数在栈中抛出一个异常，这样的处理方式就会有问题。在Herb Sutter[2]看来，这个问题可以从“异常安全”的角度完美解决，不过潜在的条件竞争，可能达成一些新的条件组合。

说一些大家没有意识到的问题：假设有一个`stack<vector<int>>`，`vector`是一个动态容器，所以当你拷贝一个`vetcor`，标准库会从堆上分配很多内存来完成这次拷贝。当这个系统处在重度负荷，或有严重的资源限制的情况下，这种内存分配就会失败，所以`vector`的拷贝构造函数可能会抛出一个`std::bad_alloc`异常。当`vector`中存有大量元素时，这种情况发生的坑内性更大。当`pop()`函数返回“弹出值”时（也就是从栈中将这个值移除），就会有一个潜在的问题：当这个值被返回到调用函数的时候，栈才被改变；但是当拷贝数据的时候，调用函数抛出一个异常会怎么样？ 如果这种事情真的发生了，要弹出的数据将会丢失；它的确从栈上一出了，但是拷贝失败了！`std::stack`的设计人员将这个操作分为两部分：先获取顶部元素（`top()`），然后从栈中移除（`pop()`）。这样，在不能安全的将元素拷贝出去的情况下，栈中的这个数据还依旧存在，没有丢失。当问题是堆空间不足，应用可能会释放一些内存，然后再进行尝试。

不幸的是，这样的分割却制造了你本想避免，或消除的条件竞争。幸运的是，我们还有的别的选项，但是这些选项是要付出代价的。

**选项1： 传入一个引用**

第一个选项是将一个变量的引用作为一个参数，传入pop()函数中来获取想要的“弹出值”：

```c++
std::vector<int> result;
some_stack.pop(result);
```

在很多情况下，这种方式表现的很好。但是，其也存在明显的缺点：需要提前构造出一个堆中类型的实例，来接收目标值。对于一些类型，这样做是不现实的，因为提前构造一个实例，从时间和资源的角度上来看，都是不经济的。对于其他的一些类型，这样做也不总能行，因为构造函数需要的一些参数，在代码的这个阶段不一定是可用的。最后，他需要存储类型是可赋值的。这是一个很重要的限制：很多用户定义类型都不支持赋值，虽然他们可能支持移动构造，甚至是拷贝构造（从而允许返回一个值）。

**选项2：无异常抛出的拷贝构造函数或移动构造函数**

对于一个有返回值的pop()函数来说，只有“异常安全”问题（当返回值时可以抛出一个异常）。很多类型都有拷贝构造函数，它们是不会抛出异常的，并且随着新标准中对“右值引用”的支持（详见附录A，A.1节），在这个前提下，很多类型都将会有一个移动构造函数，即使他们和拷贝构造函数做着相同的事情，它也不会抛出异常。一个有用的选项是能限制对线程安全的栈的使用，并且能让栈安全的返回返回所需的值，而不会抛出异常。

虽然安全，但非可靠。尽管能在编译时，使用`std::is_no_throw_copy_constructible`和`std::is_nothrow_move_constructible`类型特征，能让拷贝或移动构造函数不抛出异常，但是这个局限性太强。很多用户定义类型有可抛出异常的拷贝构造函数，没有移动构造函数；或是，都不抛出异常的构造函数（这种改变会随着C++11中左值引用，越来越为大众所用）。如果一种类型不能存储线程安全的堆栈，想想是多么的不幸呀。

**选项3：返回指向弹出值的指针**

第三个选择是返回一个指向弹出元素的指针，而不是直接返回值。指针的优势是自由拷贝，并且不会产生异常，这样你就能避免Cargill提到的异常问题了。缺点就是返回一个指针需要对对象的内存分配进行管理，不过对于简单类型（比如：int），内存管理的开销要远大于直接进行值的返回。对于选择这个方案的接口，`std::shared_ptr`是一个不错的选择；不仅是因为它能避免内存泄露（因为当对象中指针销毁时，对象也会被销毁），而且标准库能够完全控制内存分配方案，其也就不需要new和delete操作了。这种优化是很重要的：因为每个在堆栈中的对象，都需要用new进行独立的内存分配，这样一来，相较于非线程安全版本，这个方案的开销是相当大的。

**选项4：“选项1 + 选项2”或 “选项1 + 选项3”**

对于通用的代码来说，灵活性不应忽视。当你已经选择了选项2或3时，再去选择1也是很容易的。这些选项提供给用户，让用户自己选择对于他们自己来说最合适，最经济的方案。

**例：定义线程安全的堆栈**

清单3.4中是一个接口没有条件竞争的堆栈类的定义，并且它实现了选项1和选项3：这里重载了pop()，使用一个局部引用去存储弹出值，并返回一个`std::shared_ptr<>`对象。它有一个简单的接口，只有两个函数：push()和pop();

清单3.4 线程安全的堆栈类定义（概述）

```c++
#include <exception>
#include <memory>  // For std::shared_ptr<>

struct empty_stack: std::exception
{
  const char* what() const throw();
};

template<typename T>
class threadsafe_stack
{
public:
  threadsafe_stack();
  threadsafe_stack(const threadsafe_stack&);
  threadsafe_stack& operator=(const threadsafe_stack&) = delete; // 1 赋值操作被删除

  void push(T new_value);
  std::shared_ptr<T> pop();
  void pop(T& value);
  bool empty() const;
};
```




***
[1] Tom Cargill, “Exception Handling: A False Sense of Security,” in C++ Report 6, no. 9 (November–December 1994). Also available at http://www.informit.com/content/images/020163371x/supplements/Exception_Handling_Article.html.

[2] Herb Sutter, Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Solutions (Addison Wesley Pro-fessional, 1999).















