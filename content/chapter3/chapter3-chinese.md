#第三章 线程间共享数据

**本章主要内容**

>共享数据带来的问题<br>
>使用互斥量保护数据<br>
>数据保护的替代方案<br>

使用线程并发的一个好处是可以直接共享数据，我们在本章开始前，已经对线程管理有所了解了，现在让我们来看一下“共享数据的那些事”。

想象一下，当你和你的一个朋友合租在一个公寓中。公寓只有一个厨房和一个卫生间。当你要使用卫生间的时候，你的朋友一直在占用卫生间，那么你就会不能使用了（除非你们特别友好，好到可以在同一时间使用一个房间）。同样的问题也会出现在厨房，当有一个组合式烤箱，在烤香肠的时候，也在做一个蛋糕，那么我们可能得不到我们想要的食物（会得到不想要的香肠味的蛋糕）。此外，当我们在公共空间将一件事做到一半时，发现某些需要的东西被别人接走了，或者，当我们离开的一小段时间内有些东西被改动了，这都会令我们沮丧。

同样的问题，也困扰着线程。当你想要在线程见共享数据的时候，你必须定一些规矩用来限定线程可访问的数据位，还有，当一个线程更新了共享数据，需要对其他线程进行告知。从易用性上来说，在同一进程中的多个线程进行数据共享，既有利，又有弊。错误的共享数据使用是导致并发先关bug产生的一个主要原因，并且后果要比香肠味的蛋糕更加严重。

本章就在C++中，进行安全的数据共享为主题。避免上述及其他潜在问题的发生，并将共享数据的优势发挥到最大。

##3.1 共享数据带来的问题

当问题涉及到共享数据时，则该问题很可能是共享数据被修改所导致。如果所有共享数据都是只读的，那么没问题，因为只读操作不会影响到数据，更不会对数据进行修改，所以所有线程获取到的都是同样的数据。但是，当一个或多个线程要修改共享数据时，就会产生很多潜在的麻烦。在这种情况下，你就必须小心并谨慎的确保一切都工作正常。

不变量（*invariants*）的概念已经广泛使用，并且对程序员们编写的程序产生帮助——关于特殊结构体的描述，比如，“此变量包含列表中的项数”。这些不变量通常会在一次更新中被破坏，特别是哪些比较复杂的数据结构，或者一次更新就要改动很多值。

一个双链表，每一个节点都有一个指针指向列表中下一个节点，还有另外一个指针指向前一个节点。其中不变量就是节点A中指向“下一个”节点B的指针，还有前向指针。为了从列表中删除一个节点，其两边的节点的指针都需要更新。当其中一边更新完成时，不变量就被破坏了，直到另一边也完成更新；
在两边都完成更新后，不变量就又稳定了。

从一个列表中删除一个节点的步骤如下（如图3.1）<br>
1. 找到要删除的节点N<br>
2. 更新前一个节点指向N的指针，让这个指针指向N的下一个节点<br>
3. 更新后一个节点指向N的指针，让这个指正指向N的前一个节点<br>
4. 删除节点N<br>

![](https://raw.githubusercontent.com/xiaoweiChen/Cpp_Concurrency_In_Action/master/images/chapter3/3-1.png)

图3.1 从一个双链表中删除一个节点

如你所见，在图中的b和c中，在相同的方向上指向和原来已经不一致了，这就破坏不变量。

在线程间最简单的潜在问题就是修改共享数据，致使不变量遭到破坏。当你不做些事来确保在这个过程中不会有其他线程进行访问的话，可能就有线程访问到刚刚删除一边的节点，这样的话，线程就读取到要删除的那个节点的数据（因为只有一边的连接被修改，如图3.1中的b一般），所以，这里说不变量被破坏。破坏不变量的后果可能多种多样；当其他线程按从左往右的书序来访问列表，那么它将跳过那个被删除的节点。在另一方面，如有第二个线程尝试删除图中右边的节点，那么它可能会让数据结构产生永久性的损坏，并使程序崩溃。无论结果如何，这都是并行代码常见错误产生的原因：条件竞争（*race condition*）。

###3.1.1 条件竞争

假设你去电影院买电影票。如果这是一家很大的电影院，有很多收银员，那么很多人可以在同一时间进行电影票的选购。当另一个收银台也在卖你想看的这场电影的电影票，那么你的座位选择范围就取决于在之前已预定的座位。当只有少量的座位剩下，这就意味着：这可能是一场抢票比赛，看谁能抢到最后一张票。这就是一个条件竞争的例子：你的座位（或者你的电影票）都取决于两种购买方式的相对顺序。

在并发中，竞争条件的形成，取决于一个以上线程的相对执行顺序；每个线程都抢着完成自己的任务。大多数情况下，即便它们会改变执行顺序，这种竞争也是良性的，其结果也是可以接受的。例如，如果两个线程同时向一个处理队列中添加任务，谁先谁后就没有什么影响，系统提供的不变量保持不变。当不变量遭到破坏时，才会导致条件竞争，例如双向链表的那个例子。在并发中，条件竞争这个数据通常用于表示“有问题的”（*problematic*）条件竞争；我们对良性的，且不产生问题的条件竞争不感兴趣。在C++标准中，也定义了数据竞争（*data race*）这个术语，因为再并发中去修改一个独立对象（参考5.1.2节），所以这是一种特殊的条件竞争；数据竞争是（可怕的）未定义行为（*undefine behavior*）的起因。

有问题的条件竞争通常发生在，完成对多于一个的数据块的修改时，例如，对两个连接指针的修改（在图3.1中）。因为操作要访问两个独立的数据块，数据块将会被独立的指令所修改，并且另一个线程可能在只完成一半的时，就对数据块进行访问。条件竞争很难找，并且很难复现，因为概率太低。当如CPU指令那样的连续修改完成后，这个问题能再次复现出的几率就相当低了，即使这个数据结构可以让其他并发线程访问。当系统负载增加时，随着执行数量增加，执行序列的问题复现的概率也在增加。这几乎是不可避免的，这样的问题会出现在负载比较大的情况下。条件竞争通常是时间敏感的，所以，当运行在调试模式时，它们常会完全消失；因为，调试模式会影响程序的执行时间，即使影响不多。

当你以写多线程程序为生，条件竞争就会成为你生命中不快乐的源泉；在编写软件时，会使用大量复杂的操作，用来避免恶性条件竞争。

###3.1.2 避免恶性条件竞争

这里有很多方法来解决恶性条件竞争。最简单的办法是对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态。从其他访问线程的角度来看，改变要不就是已经完成了，要不就还没开始。C++标准库提供很多类似的机制，我们会在本章进行介绍。

另一个选择是改动数据结构和不变量的设计，修改完的结构需能完成一系列不可分割的变化，也就是保证每个不变量保持不变的状态。这就是无锁编程（*lock-free programming*）的方式，不过，这种方式很难得到正确的结果。如果你做到这个级别上了，无论是内存模型存在细微的差异，还是，线程有潜能看到这组值，都会让工作变的复杂。内存模型的问题将在第5章讨论，无锁编程将在第7章讨论。

另一种处理条件竞争的方式是，使用事务（*transacting*）的方式去处理数据结构的更新，这里的处理就如同数据库进行更新一样。所需的一些修改数据和读取都存储在一个事务日志中，然后将之前的操作合为一步，再进行提交。当数据结构已经被另一个线程修改后，或处理已经重启的情况下，提交会无法处理。这称作为“软件事务内存”（*software transactional memory ( STM )*），在理论研究中，这是一个很活跃研究领域。这个概念将不会在本书中再进行介绍，因为在C++中没有对STM进行直接支持。但是，基本思想我们会在后面提及。

保护共享数据结构的最基本的方式，是使用C++标准库提供的互斥量（*mutex*），我先来看一下这个。

##3.2 使用互斥量保护共享数据

当你的程序中有共享数据，你肯定不想让其陷入条件竞争，或是不变量被破坏。如果你将所有代码可访问的数据标为互相排斥（*mutually exclusive*），就很不优雅；这样的话，当其中任一线程运行访问数据时，其他线程想要访问数据，就必须等待第一个线程结束吗？这样很有可能会让一个线程看到已破坏的不变量，也就是第一个线程正在做修改的时候。

当访问共享数据前，使用互斥量将相关数据锁住，并且当访问结束后，将数据解锁。线程库需要保证，当一个线程使用一个特定互斥量锁住共享数据，其他所有的线程想要访问被锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能再进行访问。这就保证了所有线程只能看到自治区域内的共享数据，并避免不变量破坏。

互斥量是C++中用来保护数据的一种常用手段，但是互斥量不是“银弹”；它可以用来保护正确的数据（见3.2.2节），也可以避免接口中存在着的条件竞争（见3.2.3节）。互斥量自身也有问题，造成死锁（见3.2.4节），对数据保护的太多（或太少）（见3.2.8节）。

让我们从最基本的开始吧。

###3.2.1 在C++中使用互斥量

在C++中，你可以使用`srd::mutex`来创建一个互斥量实例，通过调用成员函数`lock()`进行上锁；同样的，也可以调用成员函数`unlock()`进行解锁。不过，这里不推荐实践中直接去调用成员函数，因为调用成员函数就以为着，你必须记着在每个函数出口都要去调用`unlock()`，也包括异常的情况。C++标准库提供了一个`std::lack_guard`类模板，实现了是RAII风格的互斥量；其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，这就保证了一个已锁的互斥量可以被正确的解锁。在下面的程序清单中，展示了如何在多线程程序中，使用`std::mutex`构造的`std::lock_guard`实例，对一个列表进行访问保护。`std::mutex`和`std::lock_guard`都在<mutex>头文件中声明。

列表3.1 使用互斥量保护列表
```c++
#include <list>
#include <mutex>
#include <algorithm>

std::list<int> some_list;    // 1
std::mutex some_mutex;    // 2

void add_to_list(int new_value)
{
  std::lock_guard<std::mutex> guard(some_mutex);    // 3
  some_list.push_back(new_value);
}
bool list_contains(int value_to_find)
{
  std::lock_guard<std::mutex> guard(some_mutex);    // 4
  return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();
}
```

在清单3.1中，这里有一个全局变量 ①，这个全局变量又一个全局的互斥量来保护 ②。在**add_to_list()** ③ 和**list_contains()** ④ 函数中使用`std:;lock_guard<std::mutex>`，使得在这两个函数中对数据的访问是互斥的：**list_contains()**不可能看到被**add_to_list()**修改到一半的列表。

在某些情况下，这个全局变量使用的是没问题的；不过，在大多数情况下，需要保护的数据通常会与互斥量放在同一个类中，而不是定义成全局变量。这是一个标准的面向对象设计准则：将其放在一个类中，就可让他们联系在一起，也可对类的功能进行封装，并进行数据保护。在这种情况下，函数**add_to_list**和**list_contains**可以作为这个类的成员函数，并且互斥量和要保护的数据，在类中都需要定义为private成员，这就会让访问数据的代码变的清晰，并且容易看出在什么时候对互斥量进行上锁。当所有成员函数都会在调用时对数据上锁，在结束的时候对数据解锁，那么这就为所有的访问保证了数据的不变量不被破坏。

当然，也不是什么时候都这么理想，聪明的你一定早就注意到了：当其中一个成员函数返回的是保护数据的指针或引用时，即使成员函数都很好的对数据进行了保护，但是你破坏了他们的保护。具有访问能力的指针或引用可以访问（并可能修改）被保护的数据，而不会被互斥锁限制。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门。









